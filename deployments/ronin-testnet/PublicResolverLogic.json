{
  "abi": [
    {
      "inputs": [],
      "stateMutability": "payable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidContentType",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "contentType",
          "type": "uint256"
        }
      ],
      "name": "ABIChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "AddrChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegate",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "Approved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "ContentHashChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "record",
          "type": "bytes"
        }
      ],
      "name": "DNSRecordChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        }
      ],
      "name": "DNSRecordDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "lastzonehash",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "zonehash",
          "type": "bytes"
        }
      ],
      "name": "DNSZonehashChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementer",
          "type": "address"
        }
      ],
      "name": "InterfaceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "NameChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "name": "PubkeyChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "string",
          "name": "indexedKey",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "value",
          "type": "string"
        }
      ],
      "name": "TextChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newVersion",
          "type": "uint64"
        }
      ],
      "name": "VersionChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "contentTypes",
          "type": "uint256"
        }
      ],
      "name": "ABI",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "addr",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "clearRecords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "contentHash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "resource",
          "type": "uint16"
        }
      ],
      "name": "dnsRecord",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRNSUnified",
      "outputs": [
        {
          "internalType": "contract INSUnified",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getReverseRegistrar",
      "outputs": [
        {
          "internalType": "contract INSReverseRegistrar",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        }
      ],
      "name": "hasDNSRecords",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract INSUnified",
          "name": "rnsUnified",
          "type": "address"
        },
        {
          "internalType": "contract INSReverseRegistrar",
          "name": "reverseRegistrar",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "interfaceImplementer",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "isAuthorized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "authorized",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicallWithNodeCheck",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "pubkey",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "recordVersions",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "contentType",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "setABI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "addr_",
          "type": "address"
        }
      ],
      "name": "setAddr",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "setContentHash",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "setDNSRecords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        },
        {
          "internalType": "address",
          "name": "implementer",
          "type": "address"
        }
      ],
      "name": "setInterface",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "newName",
          "type": "string"
        }
      ],
      "name": "setName",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "x",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "y",
          "type": "bytes32"
        }
      ],
      "name": "setPubkey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "value",
          "type": "string"
        }
      ],
      "name": "setText",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "hash",
          "type": "bytes"
        }
      ],
      "name": "setZonehash",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "key",
          "type": "string"
        }
      ],
      "name": "text",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "requireSuccess",
          "type": "bool"
        },
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "tryMulticall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "zonehash",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "address": "0x933Cd2272831334F1E46977BCc36153c8027Dee8",
  "args": "0x",
  "blockNumber": 21224275,
  "bytecode": "0x60806040526200000e62000014565b620000d8565b6101cd54610100900460ff1615620000825760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b6101cd5460ff90811614620000d6576101cd805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b612b7680620000e86000396000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c8063691f343111610104578063ac9650d8116100a2578063d700ff3311610071578063d700ff3314610486578063e32954eb146104c7578063e59d895d146104da578063f8014891146104ed57600080fd5b8063ac9650d8146103e5578063c869023314610405578063ce3decdc14610460578063d5fa2b001461047357600080fd5b80638c843314116100de5780638c8433141461039a578063956db465146103ac578063a821a728146103bf578063a8fa5682146103d257600080fd5b8063691f34311461036157806370687fcb14610374578063773722131461038757600080fd5b80633603d758116101715780634cbf6ba41161014b5780634cbf6ba4146102ce57806359d1d43c1461031b5780635c98042b1461033b578063623195b01461034e57600080fd5b80633603d758146102955780633b3b57de146102a8578063485cc955146102bb57600080fd5b8063124a319c116101ad578063124a319c146102245780632203ab561461024f578063237a78fb1461027057806329cd62ea1461028257600080fd5b806301ffc9a7146101d45780630af179d7146101fc57806310f13a8c14610211575b600080fd5b6101e76101e236600461219e565b610500565b60405190151581526020015b60405180910390f35b61020f61020a3660046121fc565b610511565b005b61020f61021f366004612247565b61052d565b6102376102323660046122c0565b61054d565b6040516001600160a01b0390911681526020016101f3565b61026261025d3660046122f0565b610745565b6040516101f3929190612362565b610201546001600160a01b0316610237565b61020f61029036600461237b565b61087e565b61020f6102a33660046123a7565b610894565b6102376102b63660046123a7565b6108ac565b61020f6102c93660046123d5565b61091b565b6101e76102dc3660046122f0565b6000828152603260209081526040808320546001600160401b0316835260ff825280832094835293815283822092825291909152205461ffff16151590565b61032e6103293660046121fc565b610a63565b6040516101f39190612403565b61032e6103493660046123a7565b610b45565b61020f61035c366004612416565b610c06565b61032e61036f3660046123a7565b610c24565b61020f6103823660046121fc565b610dbf565b61020f6103953660046121fc565b610dd5565b610200546001600160a01b0316610237565b6101e76103ba366004612468565b610e20565b61032e6103cd3660046123a7565b610ea5565b61032e6103e036600461248d565b610ee0565b6103f86103f3366004612511565b610f2f565b6040516101f39190612552565b61044b6104133660046123a7565b6000818152603260209081526040808320546001600160401b0316835261019982528083209383529290522080546001909101549091565b604080519283526020830191909152016101f3565b61020f61046e3660046121fc565b610f44565b61020f610481366004612468565b610f5a565b6104af6104943660046123a7565b6000908152603260205260409020546001600160401b031690565b6040516001600160401b0390911681526020016101f3565b6103f86104d53660046125b4565b610fb8565b61020f6104e83660046125f2565b611099565b6103f86104fb366004612637565b6110af565b600061050b826110bc565b92915050565b8261051c81336110e1565b610527848484611143565b50505050565b8461053881336110e1565b610545868686868661133a565b505050505050565b6000828152603260209081526040808320546001600160401b03168352610133825280832085845282528083206001600160e01b0319851684529091528120546001600160a01b031680156105a357905061050b565b60006105ae856108ac565b90506001600160a01b0381166105c95760009250505061050b565b6040516301ffc9a760e01b60248201526000906060906001600160a01b0384169060440160408051601f198184030181529181526020820180516001600160e01b03166301ffc9a760e01b179052516106229190612672565b600060405180830381855afa9150503d806000811461065d576040519150601f19603f3d011682016040523d82523d6000602084013e610662565b606091505b50909250905061067282826113f5565b61068357600094505050505061050b565b6040516001600160e01b0319871660248201526001600160a01b0384169060440160408051601f198184030181529181526020820180516001600160e01b03166301ffc9a760e01b179052516106d99190612672565b600060405180830381855afa9150503d8060008114610714576040519150601f19603f3d011682016040523d82523d6000602084013e610719565b606091505b50909250905061072982826113f5565b61073a57600094505050505061050b565b509095945050505050565b6000828152603260209081526040808320546001600160401b0316835260658252808320858452909152812060609060015b84811161085e57808516158015906107a75750600081815260208390526040812080546107a39061268e565b9050115b1561085657808260008381526020019081526020016000208080546107cb9061268e565b80601f01602080910402602001604051908101604052809291908181526020018280546107f79061268e565b80156108445780601f1061081957610100808354040283529160200191610844565b820191906000526020600020905b81548152906001019060200180831161082757829003601f168201915b50505050509050935093505050610877565b60011b610777565b5060006040518060200160405280600081525092509250505b9250929050565b8261088981336110e1565b610527848484611435565b8061089f81336110e1565b6108a8826114bd565b5050565b610200546040516331a9108f60e11b8152600481018390526000916001600160a01b031690636352211e90602401602060405180830381865afa1580156108f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050b91906126c8565b6101cd54610100900460ff161580801561093d57506101cd54600160ff909116105b806109585750303b15801561095857506101cd5460ff166001145b6109c05760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6101cd805460ff1916600117905580156109e5576101cd805461ff0019166101001790555b61020080546001600160a01b038086166001600160a01b0319928316179092556102018054928516929091169190911790558015610a5e576101cd805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b6000838152603260209081526040808320546001600160401b031683526101cc825280832086845290915290819020905160609190610aa590859085906126e5565b90815260200160405180910390208054610abe9061268e565b80601f0160208091040260200160405190810160405280929190818152602001828054610aea9061268e565b8015610b375780601f10610b0c57610100808354040283529160200191610b37565b820191906000526020600020905b815481529060010190602001808311610b1a57829003601f168201915b505050505090509392505050565b6000818152603260209081526040808320546001600160401b0316835261010082528083208484529091529020805460609190610b819061268e565b80601f0160208091040260200160405190810160405280929190818152602001828054610bad9061268e565b8015610bfa5780601f10610bcf57610100808354040283529160200191610bfa565b820191906000526020600020905b815481529060010190602001808311610bdd57829003601f168201915b50505050509050919050565b83610c1181336110e1565b610c1d85858585611527565b5050505050565b61020154604051635c9fcd8560e11b8152600481018390526060916000916001600160a01b039091169063b93f9b0a90602401602060405180830381865afa158015610c74573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c9891906126c8565b90506000610ca5846115c5565b610200546040516304c3ccb160e11b81529192506000916001600160a01b0390911690630987996290610cdc908590600401612403565b602060405180830381865afa158015610cf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1d91906126f5565b610200546040516331a9108f60e11b8152600481018390529192506001600160a01b0385811692911690636352211e90602401602060405180830381865afa158015610d6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9191906126c8565b6001600160a01b031614610db45760405180602001604052806000815250610db6565b815b95945050505050565b82610dca81336110e1565b610527848484611601565b82610de081336110e1565b6105278484848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061166b92505050565b6102005460405163fd3fa91960e01b81526001600160a01b0383811660048301526024820185905260186044830152600092169063fd3fa919906064016040805180830381865afa158015610e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e9d919061270e565b509392505050565b6000818152603260209081526040808320546001600160401b0316835260cb82528083208484529091529020805460609190610b819061268e565b6000838152603260209081526040808320546001600160401b0316835260fe82528083208684528252808320858452825280832061ffff851684529091529020805460609190610abe9061268e565b6060610f3d600184846116df565b9392505050565b82610f4f81336110e1565b6105278484846117fb565b81610f6581336110e1565b60405162461bcd60e51b815260206004820152602260248201527f5075626c69635265736f6c7665723a2043616e6e6f7420736574206164647265604482015261737360f01b60648201526084016109b7565b606083156110855760005b8281101561108357838382818110610fdd57610fdd61273d565b9050602002810190610fef9190612753565b610ffe91602491600491612799565b611007916127c3565b851461107b5760405162461bcd60e51b815260206004820152603960248201527f5075626c69635265736f6c7665723a20416c6c207265636f726473206d75737460448201527f20686176652061206d61746368696e67206e616d65686173680000000000000060648201526084016109b7565b600101610fc3565b505b611091600184846116df565b949350505050565b826110a481336110e1565b61052784848461192c565b60606110918484846116df565b60006001600160e01b03198216635497184960e01b148061050b575061050b826119c1565b6110eb8282610e20565b6108a85760405162461bcd60e51b815260206004820152602360248201527f5075626c69635265736f6c7665723a20756e617574686f72697a65642063616c6044820152623632b960e91b60648201526084016109b7565b6000838152603260209081526040808320548151601f86018490048402810184019092528482528392606092839285926001600160401b039091169183916111aa9183918c908c908190840183828082843760009201919091525092939250506119e69050565b90505b805151602082015110156112d4578661ffff1660000361121257806040015196506111d781611a47565b9450846040516020016111ea9190612672565b60405160208183030381529060405280519060200120925061120b81611a68565b93506112c6565b600061121d82611a47565b9050816040015161ffff168861ffff16141580611241575061123f8682611a84565b155b156112c45761129d8b878a8d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518d91506112949082906127f7565b8b51158a611aa2565b8160400151975081602001519650809550858051906020012093506112c182611a68565b94505b505b6112cf81611d0a565b6111ad565b5083511561132f5761132f8985888b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c925061132691508290508e6127f7565b89511588611aa2565b505050505050505050565b6000858152603260209081526040808320546001600160401b031683526101cc82528083208884529091529081902090518391839161137c90889088906126e5565b90815260200160405180910390209182611397929190612866565b5083836040516113a89291906126e5565b6040518091039020857f448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1868686866040516113e6949392919061294e565b60405180910390a35050505050565b60008280611404575060208251105b80610f3d575081601f8151811061141d5761141d61273d565b01602001516001600160f81b03191615905092915050565b6040805180820182528381526020808201848152600087815260328352848120546001600160401b03168152610199835284812088825283528490209251835551600190920191909155815184815290810183905284917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a2505050565b60008181526032602090815260409182902080546001600160401b038082166001011667ffffffffffffffff199091168117909155915191825282917fc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444910160405180910390a250565b826115336001826127f7565b161561155257604051631e76820d60e31b815260040160405180910390fd5b6000848152603260209081526040808320546001600160401b031683526065825280832087845282528083208684529091529020611591828483612866565b50604051839085907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a350505050565b6000818152603260209081526040808320546001600160401b0316835261016682528083208484529091529020805460609190610b819061268e565b6000838152603260209081526040808320546001600160401b0316835260cb82528083208684529091529020611638828483612866565b50827ff138098ddddc53c41c8649e6533fdf517348a8e9d24e9db5e5628db793fb76b483836040516114b0929190612980565b6000828152603260209081526040808320546001600160401b03168352610166825280832085845290915290206116a28282612994565b50817fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f7826040516116d39190612403565b60405180910390a25050565b606081806001600160401b038111156116fa576116fa61280a565b60405190808252806020026020018201604052801561172d57816020015b60608152602001906001900390816117185790505b5091506000606060005b838110156117f057308787838181106117525761175261273d565b90506020028101906117649190612753565b6040516117729291906126e5565b600060405180830381855af49150503d80600081146117ad576040519150601f19603f3d011682016040523d82523d6000602084013e6117b2565b606091505b50909350915087156117ca576117ca83151583611df2565b818582815181106117dd576117dd61273d565b6020908102919091010152600101611737565b505050509392505050565b6000838152603260209081526040808320546001600160401b03168084526101008352818420878552909252822080549192916118379061268e565b80601f01602080910402602001604051908101604052809291908181526020018280546118639061268e565b80156118b05780601f10611885576101008083540402835291602001916118b0565b820191906000526020600020905b81548152906001019060200180831161189357829003601f168201915b505050506001600160401b0384166000908152610100602090815260408083208a845290915290209192506118e89050848683612866565b50847f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582868660405161191d93929190612a53565b60405180910390a25050505050565b6000838152603260209081526040808320546001600160401b03168352610133825280832086845282528083206001600160e01b031986168085529083529281902080546001600160a01b0319166001600160a01b038616908117909155905190815285917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a3505050565b60006001600160e01b031982166304920eeb60e41b148061050b575061050b82611e15565b611a346040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261050b81611d0a565b6020810151815160609161050b91611a5f9082611e3a565b84519190611e94565b60a081015160c082015160609161050b91611a5f9082906127f7565b600081518351148015610f3d5750610f3d8360008460008751611f0a565b865160208801206000611ab6878787611e94565b90508315611bdd576001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611b009061268e565b159050611b5e576001600160401b038316600090815260ff602090815260408083208d845282528083208584529091528120805461ffff1691611b4283612a83565b91906101000a81548161ffff021916908361ffff160217905550505b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c1684529091528120611b9e91612132565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611bd0929190612aa1565b60405180910390a2611cfe565b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611c1f9061268e565b9050600003611c7f576001600160401b038316600090815260ff602090815260408083208d845282528083208584529091528120805461ffff1691611c6383612ac7565b91906101000a81548161ffff021916908361ffff160217905550505b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020611cc08282612994565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611cf593929190612ae8565b60405180910390a25b50505050505050505050565b60c08101516020820181905281515111611d215750565b6000611d3582600001518360200151611e3a565b8260200151611d449190612b17565b8251909150611d539082611f2d565b61ffff166040830152611d67600282612b17565b8251909150611d769082611f2d565b61ffff166060830152611d8a600282612b17565b8251909150611d999082611f55565b63ffffffff166080830152611daf600482612b17565b8251909150600090611dc19083611f2d565b61ffff169050611dd2600283612b17565b60a084018190529150611de58183612b17565b60c0909301929092525050565b816108a85780518015611e06578060208301fd5b5063350c20f16000526004601cfd5b60006001600160e01b0319821663e1a460d960e01b148061050b575061050b82611f7f565b6000815b83518110611e4e57611e4e612b2a565b6000611e5a8583611fa4565b60ff169050611e6a816001612b17565b611e749083612b17565b915080600003611e845750611e8a565b50611e3e565b61109183826127f7565b8251606090611ea38385612b17565b1115611eae57600080fd5b6000826001600160401b03811115611ec857611ec861280a565b6040519080825280601f01601f191660200182016040528015611ef2576020820181803683370190505b5090506020808201908686010161073a828287611fc8565b6000611f1784848461201e565b611f2287878561201e565b149695505050505050565b8151600090611f3d836002612b17565b1115611f4857600080fd5b50016002015161ffff1690565b8151600090611f65836004612b17565b1115611f7057600080fd5b50016004015163ffffffff1690565b60006001600160e01b03198216630f140b1160e11b148061050b575061050b82612042565b6000828281518110611fb857611fb861273d565b016020015160f81c905092915050565b602081106120005781518352611fdf602084612b17565b9250611fec602083612b17565b9150611ff96020826127f7565b9050611fc8565b905182516020929092036101000a6000190180199091169116179052565b825160009061202d8385612b17565b111561203857600080fd5b5091016020012090565b60006001600160e01b0319821663f7d7b8c160e01b148061050b575061050b8260006001600160e01b0319821663a20b2f5560e01b148061209357506001600160e01b031982166392a5e8f760e01b145b8061050b575061050b8260006001600160e01b0319821663d849d8e360e01b148061050b575061050b8260006001600160e01b03198216637760be6f60e11b148061050b575061050b8260006001600160e01b031982166320191f7360e11b148061050b575061050b8260006001600160e01b0319821663e103286b60e01b148061050b57506301ffc9a760e01b6001600160e01b031983161461050b565b50805461213e9061268e565b6000825580601f1061214e575050565b601f01602090049060005260206000209081019061216c919061216f565b50565b5b808211156121845760008155600101612170565b5090565b6001600160e01b03198116811461216c57600080fd5b6000602082840312156121b057600080fd5b8135610f3d81612188565b60008083601f8401126121cd57600080fd5b5081356001600160401b038111156121e457600080fd5b60208301915083602082850101111561087757600080fd5b60008060006040848603121561221157600080fd5b8335925060208401356001600160401b0381111561222e57600080fd5b61223a868287016121bb565b9497909650939450505050565b60008060008060006060868803121561225f57600080fd5b8535945060208601356001600160401b038082111561227d57600080fd5b61228989838a016121bb565b909650945060408801359150808211156122a257600080fd5b506122af888289016121bb565b969995985093965092949392505050565b600080604083850312156122d357600080fd5b8235915060208301356122e581612188565b809150509250929050565b6000806040838503121561230357600080fd5b50508035926020909101359150565b60005b8381101561232d578181015183820152602001612315565b50506000910152565b6000815180845261234e816020860160208601612312565b601f01601f19169290920160200192915050565b8281526040602082015260006110916040830184612336565b60008060006060848603121561239057600080fd5b505081359360208301359350604090920135919050565b6000602082840312156123b957600080fd5b5035919050565b6001600160a01b038116811461216c57600080fd5b600080604083850312156123e857600080fd5b82356123f3816123c0565b915060208301356122e5816123c0565b602081526000610f3d6020830184612336565b6000806000806060858703121561242c57600080fd5b843593506020850135925060408501356001600160401b0381111561245057600080fd5b61245c878288016121bb565b95989497509550505050565b6000806040838503121561247b57600080fd5b8235915060208301356122e5816123c0565b6000806000606084860312156124a257600080fd5b8335925060208401359150604084013561ffff811681146124c257600080fd5b809150509250925092565b60008083601f8401126124df57600080fd5b5081356001600160401b038111156124f657600080fd5b6020830191508360208260051b850101111561087757600080fd5b6000806020838503121561252457600080fd5b82356001600160401b0381111561253a57600080fd5b612546858286016124cd565b90969095509350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156125a757603f19888603018452612595858351612336565b94509285019290850190600101612579565b5092979650505050505050565b6000806000604084860312156125c957600080fd5b8335925060208401356001600160401b038111156125e657600080fd5b61223a868287016124cd565b60008060006060848603121561260757600080fd5b83359250602084013561261981612188565b915060408401356124c2816123c0565b801515811461216c57600080fd5b60008060006040848603121561264c57600080fd5b833561265781612629565b925060208401356001600160401b038111156125e657600080fd5b60008251612684818460208701612312565b9190910192915050565b600181811c908216806126a257607f821691505b6020821081036126c257634e487b7160e01b600052602260045260246000fd5b50919050565b6000602082840312156126da57600080fd5b8151610f3d816123c0565b8183823760009101908152919050565b60006020828403121561270757600080fd5b5051919050565b6000806040838503121561272157600080fd5b825161272c81612629565b60208401519092506122e581612188565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261276a57600080fd5b8301803591506001600160401b0382111561278457600080fd5b60200191503681900382131561087757600080fd5b600080858511156127a957600080fd5b838611156127b657600080fd5b5050820193919092039150565b8035602083101561050b57600019602084900360031b1b1692915050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561050b5761050b6127e1565b634e487b7160e01b600052604160045260246000fd5b601f821115610a5e57600081815260208120601f850160051c810160208610156128475750805b601f850160051c820191505b8181101561054557828155600101612853565b6001600160401b0383111561287d5761287d61280a565b6128918361288b835461268e565b83612820565b6000601f8411600181146128c557600085156128ad5750838201355b600019600387901b1c1916600186901b178355610c1d565b600083815260209020601f19861690835b828110156128f657868501358255602094850194600190920191016128d6565b50868210156129135760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b604081526000612962604083018688612925565b8281036020840152612975818587612925565b979650505050505050565b602081526000611091602083018486612925565b81516001600160401b038111156129ad576129ad61280a565b6129c1816129bb845461268e565b84612820565b602080601f8311600181146129f657600084156129de5750858301515b600019600386901b1c1916600185901b178555610545565b600085815260208120601f198616915b82811015612a2557888601518255948401946001909101908401612a06565b5085821015612a435787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b604081526000612a666040830186612336565b8281036020840152612a79818587612925565b9695505050505050565b600061ffff821680612a9757612a976127e1565b6000190192915050565b604081526000612ab46040830185612336565b905061ffff831660208301529392505050565b600061ffff808316818103612ade57612ade6127e1565b6001019392505050565b606081526000612afb6060830186612336565b61ffff851660208401528281036040840152612a798185612336565b8082018082111561050b5761050b6127e1565b634e487b7160e01b600052600160045260246000fdfea264697066735822122071bbc4bff126add9e96885c48993935407bf76c98e0f32dfd2c1c91c3f35e40664736f6c63430008150033",
  "chainId": 2021,
  "contractName": "PublicResolver",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c8063691f343111610104578063ac9650d8116100a2578063d700ff3311610071578063d700ff3314610486578063e32954eb146104c7578063e59d895d146104da578063f8014891146104ed57600080fd5b8063ac9650d8146103e5578063c869023314610405578063ce3decdc14610460578063d5fa2b001461047357600080fd5b80638c843314116100de5780638c8433141461039a578063956db465146103ac578063a821a728146103bf578063a8fa5682146103d257600080fd5b8063691f34311461036157806370687fcb14610374578063773722131461038757600080fd5b80633603d758116101715780634cbf6ba41161014b5780634cbf6ba4146102ce57806359d1d43c1461031b5780635c98042b1461033b578063623195b01461034e57600080fd5b80633603d758146102955780633b3b57de146102a8578063485cc955146102bb57600080fd5b8063124a319c116101ad578063124a319c146102245780632203ab561461024f578063237a78fb1461027057806329cd62ea1461028257600080fd5b806301ffc9a7146101d45780630af179d7146101fc57806310f13a8c14610211575b600080fd5b6101e76101e236600461219e565b610500565b60405190151581526020015b60405180910390f35b61020f61020a3660046121fc565b610511565b005b61020f61021f366004612247565b61052d565b6102376102323660046122c0565b61054d565b6040516001600160a01b0390911681526020016101f3565b61026261025d3660046122f0565b610745565b6040516101f3929190612362565b610201546001600160a01b0316610237565b61020f61029036600461237b565b61087e565b61020f6102a33660046123a7565b610894565b6102376102b63660046123a7565b6108ac565b61020f6102c93660046123d5565b61091b565b6101e76102dc3660046122f0565b6000828152603260209081526040808320546001600160401b0316835260ff825280832094835293815283822092825291909152205461ffff16151590565b61032e6103293660046121fc565b610a63565b6040516101f39190612403565b61032e6103493660046123a7565b610b45565b61020f61035c366004612416565b610c06565b61032e61036f3660046123a7565b610c24565b61020f6103823660046121fc565b610dbf565b61020f6103953660046121fc565b610dd5565b610200546001600160a01b0316610237565b6101e76103ba366004612468565b610e20565b61032e6103cd3660046123a7565b610ea5565b61032e6103e036600461248d565b610ee0565b6103f86103f3366004612511565b610f2f565b6040516101f39190612552565b61044b6104133660046123a7565b6000818152603260209081526040808320546001600160401b0316835261019982528083209383529290522080546001909101549091565b604080519283526020830191909152016101f3565b61020f61046e3660046121fc565b610f44565b61020f610481366004612468565b610f5a565b6104af6104943660046123a7565b6000908152603260205260409020546001600160401b031690565b6040516001600160401b0390911681526020016101f3565b6103f86104d53660046125b4565b610fb8565b61020f6104e83660046125f2565b611099565b6103f86104fb366004612637565b6110af565b600061050b826110bc565b92915050565b8261051c81336110e1565b610527848484611143565b50505050565b8461053881336110e1565b610545868686868661133a565b505050505050565b6000828152603260209081526040808320546001600160401b03168352610133825280832085845282528083206001600160e01b0319851684529091528120546001600160a01b031680156105a357905061050b565b60006105ae856108ac565b90506001600160a01b0381166105c95760009250505061050b565b6040516301ffc9a760e01b60248201526000906060906001600160a01b0384169060440160408051601f198184030181529181526020820180516001600160e01b03166301ffc9a760e01b179052516106229190612672565b600060405180830381855afa9150503d806000811461065d576040519150601f19603f3d011682016040523d82523d6000602084013e610662565b606091505b50909250905061067282826113f5565b61068357600094505050505061050b565b6040516001600160e01b0319871660248201526001600160a01b0384169060440160408051601f198184030181529181526020820180516001600160e01b03166301ffc9a760e01b179052516106d99190612672565b600060405180830381855afa9150503d8060008114610714576040519150601f19603f3d011682016040523d82523d6000602084013e610719565b606091505b50909250905061072982826113f5565b61073a57600094505050505061050b565b509095945050505050565b6000828152603260209081526040808320546001600160401b0316835260658252808320858452909152812060609060015b84811161085e57808516158015906107a75750600081815260208390526040812080546107a39061268e565b9050115b1561085657808260008381526020019081526020016000208080546107cb9061268e565b80601f01602080910402602001604051908101604052809291908181526020018280546107f79061268e565b80156108445780601f1061081957610100808354040283529160200191610844565b820191906000526020600020905b81548152906001019060200180831161082757829003601f168201915b50505050509050935093505050610877565b60011b610777565b5060006040518060200160405280600081525092509250505b9250929050565b8261088981336110e1565b610527848484611435565b8061089f81336110e1565b6108a8826114bd565b5050565b610200546040516331a9108f60e11b8152600481018390526000916001600160a01b031690636352211e90602401602060405180830381865afa1580156108f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050b91906126c8565b6101cd54610100900460ff161580801561093d57506101cd54600160ff909116105b806109585750303b15801561095857506101cd5460ff166001145b6109c05760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6101cd805460ff1916600117905580156109e5576101cd805461ff0019166101001790555b61020080546001600160a01b038086166001600160a01b0319928316179092556102018054928516929091169190911790558015610a5e576101cd805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b6000838152603260209081526040808320546001600160401b031683526101cc825280832086845290915290819020905160609190610aa590859085906126e5565b90815260200160405180910390208054610abe9061268e565b80601f0160208091040260200160405190810160405280929190818152602001828054610aea9061268e565b8015610b375780601f10610b0c57610100808354040283529160200191610b37565b820191906000526020600020905b815481529060010190602001808311610b1a57829003601f168201915b505050505090509392505050565b6000818152603260209081526040808320546001600160401b0316835261010082528083208484529091529020805460609190610b819061268e565b80601f0160208091040260200160405190810160405280929190818152602001828054610bad9061268e565b8015610bfa5780601f10610bcf57610100808354040283529160200191610bfa565b820191906000526020600020905b815481529060010190602001808311610bdd57829003601f168201915b50505050509050919050565b83610c1181336110e1565b610c1d85858585611527565b5050505050565b61020154604051635c9fcd8560e11b8152600481018390526060916000916001600160a01b039091169063b93f9b0a90602401602060405180830381865afa158015610c74573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c9891906126c8565b90506000610ca5846115c5565b610200546040516304c3ccb160e11b81529192506000916001600160a01b0390911690630987996290610cdc908590600401612403565b602060405180830381865afa158015610cf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d1d91906126f5565b610200546040516331a9108f60e11b8152600481018390529192506001600160a01b0385811692911690636352211e90602401602060405180830381865afa158015610d6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d9191906126c8565b6001600160a01b031614610db45760405180602001604052806000815250610db6565b815b95945050505050565b82610dca81336110e1565b610527848484611601565b82610de081336110e1565b6105278484848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061166b92505050565b6102005460405163fd3fa91960e01b81526001600160a01b0383811660048301526024820185905260186044830152600092169063fd3fa919906064016040805180830381865afa158015610e79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e9d919061270e565b509392505050565b6000818152603260209081526040808320546001600160401b0316835260cb82528083208484529091529020805460609190610b819061268e565b6000838152603260209081526040808320546001600160401b0316835260fe82528083208684528252808320858452825280832061ffff851684529091529020805460609190610abe9061268e565b6060610f3d600184846116df565b9392505050565b82610f4f81336110e1565b6105278484846117fb565b81610f6581336110e1565b60405162461bcd60e51b815260206004820152602260248201527f5075626c69635265736f6c7665723a2043616e6e6f7420736574206164647265604482015261737360f01b60648201526084016109b7565b606083156110855760005b8281101561108357838382818110610fdd57610fdd61273d565b9050602002810190610fef9190612753565b610ffe91602491600491612799565b611007916127c3565b851461107b5760405162461bcd60e51b815260206004820152603960248201527f5075626c69635265736f6c7665723a20416c6c207265636f726473206d75737460448201527f20686176652061206d61746368696e67206e616d65686173680000000000000060648201526084016109b7565b600101610fc3565b505b611091600184846116df565b949350505050565b826110a481336110e1565b61052784848461192c565b60606110918484846116df565b60006001600160e01b03198216635497184960e01b148061050b575061050b826119c1565b6110eb8282610e20565b6108a85760405162461bcd60e51b815260206004820152602360248201527f5075626c69635265736f6c7665723a20756e617574686f72697a65642063616c6044820152623632b960e91b60648201526084016109b7565b6000838152603260209081526040808320548151601f86018490048402810184019092528482528392606092839285926001600160401b039091169183916111aa9183918c908c908190840183828082843760009201919091525092939250506119e69050565b90505b805151602082015110156112d4578661ffff1660000361121257806040015196506111d781611a47565b9450846040516020016111ea9190612672565b60405160208183030381529060405280519060200120925061120b81611a68565b93506112c6565b600061121d82611a47565b9050816040015161ffff168861ffff16141580611241575061123f8682611a84565b155b156112c45761129d8b878a8d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518d91506112949082906127f7565b8b51158a611aa2565b8160400151975081602001519650809550858051906020012093506112c182611a68565b94505b505b6112cf81611d0a565b6111ad565b5083511561132f5761132f8985888b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c925061132691508290508e6127f7565b89511588611aa2565b505050505050505050565b6000858152603260209081526040808320546001600160401b031683526101cc82528083208884529091529081902090518391839161137c90889088906126e5565b90815260200160405180910390209182611397929190612866565b5083836040516113a89291906126e5565b6040518091039020857f448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1868686866040516113e6949392919061294e565b60405180910390a35050505050565b60008280611404575060208251105b80610f3d575081601f8151811061141d5761141d61273d565b01602001516001600160f81b03191615905092915050565b6040805180820182528381526020808201848152600087815260328352848120546001600160401b03168152610199835284812088825283528490209251835551600190920191909155815184815290810183905284917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a2505050565b60008181526032602090815260409182902080546001600160401b038082166001011667ffffffffffffffff199091168117909155915191825282917fc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444910160405180910390a250565b826115336001826127f7565b161561155257604051631e76820d60e31b815260040160405180910390fd5b6000848152603260209081526040808320546001600160401b031683526065825280832087845282528083208684529091529020611591828483612866565b50604051839085907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a350505050565b6000818152603260209081526040808320546001600160401b0316835261016682528083208484529091529020805460609190610b819061268e565b6000838152603260209081526040808320546001600160401b0316835260cb82528083208684529091529020611638828483612866565b50827ff138098ddddc53c41c8649e6533fdf517348a8e9d24e9db5e5628db793fb76b483836040516114b0929190612980565b6000828152603260209081526040808320546001600160401b03168352610166825280832085845290915290206116a28282612994565b50817fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f7826040516116d39190612403565b60405180910390a25050565b606081806001600160401b038111156116fa576116fa61280a565b60405190808252806020026020018201604052801561172d57816020015b60608152602001906001900390816117185790505b5091506000606060005b838110156117f057308787838181106117525761175261273d565b90506020028101906117649190612753565b6040516117729291906126e5565b600060405180830381855af49150503d80600081146117ad576040519150601f19603f3d011682016040523d82523d6000602084013e6117b2565b606091505b50909350915087156117ca576117ca83151583611df2565b818582815181106117dd576117dd61273d565b6020908102919091010152600101611737565b505050509392505050565b6000838152603260209081526040808320546001600160401b03168084526101008352818420878552909252822080549192916118379061268e565b80601f01602080910402602001604051908101604052809291908181526020018280546118639061268e565b80156118b05780601f10611885576101008083540402835291602001916118b0565b820191906000526020600020905b81548152906001019060200180831161189357829003601f168201915b505050506001600160401b0384166000908152610100602090815260408083208a845290915290209192506118e89050848683612866565b50847f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582868660405161191d93929190612a53565b60405180910390a25050505050565b6000838152603260209081526040808320546001600160401b03168352610133825280832086845282528083206001600160e01b031986168085529083529281902080546001600160a01b0319166001600160a01b038616908117909155905190815285917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a3505050565b60006001600160e01b031982166304920eeb60e41b148061050b575061050b82611e15565b611a346040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c0810182905261050b81611d0a565b6020810151815160609161050b91611a5f9082611e3a565b84519190611e94565b60a081015160c082015160609161050b91611a5f9082906127f7565b600081518351148015610f3d5750610f3d8360008460008751611f0a565b865160208801206000611ab6878787611e94565b90508315611bdd576001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611b009061268e565b159050611b5e576001600160401b038316600090815260ff602090815260408083208d845282528083208584529091528120805461ffff1691611b4283612a83565b91906101000a81548161ffff021916908361ffff160217905550505b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c1684529091528120611b9e91612132565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611bd0929190612aa1565b60405180910390a2611cfe565b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611c1f9061268e565b9050600003611c7f576001600160401b038316600090815260ff602090815260408083208d845282528083208584529091528120805461ffff1691611c6383612ac7565b91906101000a81548161ffff021916908361ffff160217905550505b6001600160401b038316600090815260fe602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020611cc08282612994565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611cf593929190612ae8565b60405180910390a25b50505050505050505050565b60c08101516020820181905281515111611d215750565b6000611d3582600001518360200151611e3a565b8260200151611d449190612b17565b8251909150611d539082611f2d565b61ffff166040830152611d67600282612b17565b8251909150611d769082611f2d565b61ffff166060830152611d8a600282612b17565b8251909150611d999082611f55565b63ffffffff166080830152611daf600482612b17565b8251909150600090611dc19083611f2d565b61ffff169050611dd2600283612b17565b60a084018190529150611de58183612b17565b60c0909301929092525050565b816108a85780518015611e06578060208301fd5b5063350c20f16000526004601cfd5b60006001600160e01b0319821663e1a460d960e01b148061050b575061050b82611f7f565b6000815b83518110611e4e57611e4e612b2a565b6000611e5a8583611fa4565b60ff169050611e6a816001612b17565b611e749083612b17565b915080600003611e845750611e8a565b50611e3e565b61109183826127f7565b8251606090611ea38385612b17565b1115611eae57600080fd5b6000826001600160401b03811115611ec857611ec861280a565b6040519080825280601f01601f191660200182016040528015611ef2576020820181803683370190505b5090506020808201908686010161073a828287611fc8565b6000611f1784848461201e565b611f2287878561201e565b149695505050505050565b8151600090611f3d836002612b17565b1115611f4857600080fd5b50016002015161ffff1690565b8151600090611f65836004612b17565b1115611f7057600080fd5b50016004015163ffffffff1690565b60006001600160e01b03198216630f140b1160e11b148061050b575061050b82612042565b6000828281518110611fb857611fb861273d565b016020015160f81c905092915050565b602081106120005781518352611fdf602084612b17565b9250611fec602083612b17565b9150611ff96020826127f7565b9050611fc8565b905182516020929092036101000a6000190180199091169116179052565b825160009061202d8385612b17565b111561203857600080fd5b5091016020012090565b60006001600160e01b0319821663f7d7b8c160e01b148061050b575061050b8260006001600160e01b0319821663a20b2f5560e01b148061209357506001600160e01b031982166392a5e8f760e01b145b8061050b575061050b8260006001600160e01b0319821663d849d8e360e01b148061050b575061050b8260006001600160e01b03198216637760be6f60e11b148061050b575061050b8260006001600160e01b031982166320191f7360e11b148061050b575061050b8260006001600160e01b0319821663e103286b60e01b148061050b57506301ffc9a760e01b6001600160e01b031983161461050b565b50805461213e9061268e565b6000825580601f1061214e575050565b601f01602090049060005260206000209081019061216c919061216f565b50565b5b808211156121845760008155600101612170565b5090565b6001600160e01b03198116811461216c57600080fd5b6000602082840312156121b057600080fd5b8135610f3d81612188565b60008083601f8401126121cd57600080fd5b5081356001600160401b038111156121e457600080fd5b60208301915083602082850101111561087757600080fd5b60008060006040848603121561221157600080fd5b8335925060208401356001600160401b0381111561222e57600080fd5b61223a868287016121bb565b9497909650939450505050565b60008060008060006060868803121561225f57600080fd5b8535945060208601356001600160401b038082111561227d57600080fd5b61228989838a016121bb565b909650945060408801359150808211156122a257600080fd5b506122af888289016121bb565b969995985093965092949392505050565b600080604083850312156122d357600080fd5b8235915060208301356122e581612188565b809150509250929050565b6000806040838503121561230357600080fd5b50508035926020909101359150565b60005b8381101561232d578181015183820152602001612315565b50506000910152565b6000815180845261234e816020860160208601612312565b601f01601f19169290920160200192915050565b8281526040602082015260006110916040830184612336565b60008060006060848603121561239057600080fd5b505081359360208301359350604090920135919050565b6000602082840312156123b957600080fd5b5035919050565b6001600160a01b038116811461216c57600080fd5b600080604083850312156123e857600080fd5b82356123f3816123c0565b915060208301356122e5816123c0565b602081526000610f3d6020830184612336565b6000806000806060858703121561242c57600080fd5b843593506020850135925060408501356001600160401b0381111561245057600080fd5b61245c878288016121bb565b95989497509550505050565b6000806040838503121561247b57600080fd5b8235915060208301356122e5816123c0565b6000806000606084860312156124a257600080fd5b8335925060208401359150604084013561ffff811681146124c257600080fd5b809150509250925092565b60008083601f8401126124df57600080fd5b5081356001600160401b038111156124f657600080fd5b6020830191508360208260051b850101111561087757600080fd5b6000806020838503121561252457600080fd5b82356001600160401b0381111561253a57600080fd5b612546858286016124cd565b90969095509350505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b828110156125a757603f19888603018452612595858351612336565b94509285019290850190600101612579565b5092979650505050505050565b6000806000604084860312156125c957600080fd5b8335925060208401356001600160401b038111156125e657600080fd5b61223a868287016124cd565b60008060006060848603121561260757600080fd5b83359250602084013561261981612188565b915060408401356124c2816123c0565b801515811461216c57600080fd5b60008060006040848603121561264c57600080fd5b833561265781612629565b925060208401356001600160401b038111156125e657600080fd5b60008251612684818460208701612312565b9190910192915050565b600181811c908216806126a257607f821691505b6020821081036126c257634e487b7160e01b600052602260045260246000fd5b50919050565b6000602082840312156126da57600080fd5b8151610f3d816123c0565b8183823760009101908152919050565b60006020828403121561270757600080fd5b5051919050565b6000806040838503121561272157600080fd5b825161272c81612629565b60208401519092506122e581612188565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261276a57600080fd5b8301803591506001600160401b0382111561278457600080fd5b60200191503681900382131561087757600080fd5b600080858511156127a957600080fd5b838611156127b657600080fd5b5050820193919092039150565b8035602083101561050b57600019602084900360031b1b1692915050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561050b5761050b6127e1565b634e487b7160e01b600052604160045260246000fd5b601f821115610a5e57600081815260208120601f850160051c810160208610156128475750805b601f850160051c820191505b8181101561054557828155600101612853565b6001600160401b0383111561287d5761287d61280a565b6128918361288b835461268e565b83612820565b6000601f8411600181146128c557600085156128ad5750838201355b600019600387901b1c1916600186901b178355610c1d565b600083815260209020601f19861690835b828110156128f657868501358255602094850194600190920191016128d6565b50868210156129135760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b604081526000612962604083018688612925565b8281036020840152612975818587612925565b979650505050505050565b602081526000611091602083018486612925565b81516001600160401b038111156129ad576129ad61280a565b6129c1816129bb845461268e565b84612820565b602080601f8311600181146129f657600084156129de5750858301515b600019600386901b1c1916600185901b178555610545565b600085815260208120601f198616915b82811015612a2557888601518255948401946001909101908401612a06565b5085821015612a435787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b604081526000612a666040830186612336565b8281036020840152612a79818587612925565b9695505050505050565b600061ffff821680612a9757612a976127e1565b6000190192915050565b604081526000612ab46040830185612336565b905061ffff831660208301529392505050565b600061ffff808316818103612ade57612ade6127e1565b6001019392505050565b606081526000612afb6060830186612336565b61ffff851660208401528281036040840152612a798185612336565b8082018082111561050b5761050b6127e1565b634e487b7160e01b600052600160045260246000fdfea264697066735822122071bbc4bff126add9e96885c48993935407bf76c98e0f32dfd2c1c91c3f35e40664736f6c63430008150033",
  "deployer": "0x968D0Cd7343f711216817E617d3f92a23dC91c07",
  "devdoc": {
    "version": 1,
    "kind": "dev",
    "details": "A simple resolver anyone can use, only allows the owner of a node to set its address.",
    "methods": {
      "ABI(bytes32,uint256)": {
        "details": "Returns the ABI associated with an INS node. Defined in EIP-205, see more at https://eips.ethereum.org/EIPS/eip-205",
        "params": {
          "contentTypes": "A bitwise OR of the ABI formats accepted by the caller.",
          "node": "The INS node to query"
        },
        "returns": {
          "_0": "The content type of the return value",
          "_1": "The ABI data"
        }
      },
      "addr(bytes32)": {
        "details": "Override {IAddressResolvable-addr}."
      },
      "clearRecords(bytes32)": {
        "details": "Increments the record version associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {VersionChanged}.",
        "params": {
          "node": "The node to update."
        }
      },
      "contentHash(bytes32)": {
        "details": "Returns the content hash associated with an INS node.",
        "params": {
          "node": "The INS node to query."
        },
        "returns": {
          "_0": "The associated content hash."
        }
      },
      "dnsRecord(bytes32,bytes32,uint16)": {
        "details": "Obtain a DNS record.",
        "params": {
          "name": "the keccak-256 hash of the fully-qualified name for which to fetch the record",
          "node": "the namehash of the node for which to fetch the record",
          "resource": "the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types"
        },
        "returns": {
          "_0": "the DNS record in wire format if present, otherwise empty"
        }
      },
      "getRNSUnified()": {
        "details": "Retrieves the RNSUnified associated with this resolver."
      },
      "getReverseRegistrar()": {
        "details": "Retrieves the reverse registrar associated with this resolver."
      },
      "hasDNSRecords(bytes32,bytes32)": {
        "details": "Checks whether a given node has records.",
        "params": {
          "name": "the namehash of the node for which to check the records",
          "node": "the namehash of the node for which to check the records"
        }
      },
      "interfaceImplementer(bytes32,bytes4)": {
        "details": "Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned.",
        "params": {
          "interfaceID": "The EIP 165 interface ID to check for.",
          "node": "The INS node to query."
        },
        "returns": {
          "_0": "The address that implements this interface, or 0 if the interface is unsupported."
        }
      },
      "isAuthorized(bytes32,address)": {
        "details": "Checks if an account is authorized to manage the resolution of a specific RNS node.",
        "params": {
          "account": "The account address being checked for authorization.",
          "node": "The RNS node."
        },
        "returns": {
          "authorized": "A boolean indicating whether the account is authorized."
        }
      },
      "multicall(bytes[])": {
        "details": "Executes bulk action to the original contract. Reverts if there is a single call failed.",
        "params": {
          "data": "The calldata to original contract."
        }
      },
      "multicallWithNodeCheck(bytes32,bytes[])": {
        "details": "This function provides an extra security check when called from privileged contracts (such as RONRegistrarController) that can set records on behalf of the node owners. Reverts if the node is not null but calldata is mismatched."
      },
      "name(bytes32)": {
        "details": "Override {INameResolver-name}."
      },
      "pubkey(bytes32)": {
        "details": "See {IPublicKeyResolver-pubkey}."
      },
      "recordVersions(bytes32)": {
        "details": "Returns the latest version of a node."
      },
      "setABI(bytes32,uint256,bytes)": {
        "details": "Sets the ABI associated with an INS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. - The content type must be powers of 2. Emitted an event {ABIChanged}.",
        "params": {
          "contentType": "The content type of the ABI",
          "data": "The ABI data.",
          "node": "The node to update."
        }
      },
      "setAddr(bytes32,address)": {
        "details": "Sets the address associated with an INS node. Requirement: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {AddrChanged}.",
        "params": {
          "addr": "The address to set.",
          "node": "The node to update."
        }
      },
      "setContentHash(bytes32,bytes)": {
        "details": "Sets the content hash associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {ContentHashChanged}.",
        "params": {
          "hash": "The content hash to set",
          "node": "The node to update."
        }
      },
      "setDNSRecords(bytes32,bytes)": {
        "details": "Set one or more DNS records.  Records are supplied in wire-format.  Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:   a.example.com IN A 1.2.3.4   a.example.com IN A 5.6.7.8   www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:   a.example.com IN A 1.2.3.4   www.example.com IN CNAME a.example.com.   a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}.",
        "params": {
          "data": "the DNS wire format records to set",
          "node": "the namehash of the node for which to set the records"
        }
      },
      "setInterface(bytes32,bytes4,address)": {
        "details": "Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}.",
        "params": {
          "implementer": "The address of a contract that implements this interface for this node.",
          "interfaceID": "The EIP 165 interface ID.",
          "node": "The node to update."
        }
      },
      "setName(bytes32,string)": {
        "details": "Sets the name associated with an INS node, for reverse records. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {NameChanged}.",
        "params": {
          "node": "The node to update."
        }
      },
      "setPubkey(bytes32,bytes32,bytes32)": {
        "details": "Sets the SECP256k1 public key associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {PubkeyChanged}.",
        "params": {
          "node": "The INS node to query",
          "x": "the X coordinate of the curve point for the public key.",
          "y": "the Y coordinate of the curve point for the public key."
        }
      },
      "setText(bytes32,string,string)": {
        "details": "Sets the text data associated with an INS node and key. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {TextChanged}.",
        "params": {
          "key": "The key to set.",
          "node": "The node to update.",
          "value": "The text data value to set."
        }
      },
      "setZonehash(bytes32,bytes)": {
        "details": "Sets the hash for the zone. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {DNSZonehashChanged}.",
        "params": {
          "hash": "The zonehash to set",
          "node": "The node to update."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Override {IERC165-supportsInterface}."
      },
      "text(bytes32,string)": {
        "params": {
          "key": "The text data key to query.",
          "node": "The INS node to query."
        },
        "returns": {
          "_0": "The associated text data."
        }
      },
      "tryMulticall(bool,bytes[])": {
        "details": "Executes bulk action to the original contract.",
        "params": {
          "data": "The calldata to original contract.",
          "requireSuccess": "Flag to indicating whether the contract reverts if there is a single call failed."
        }
      },
      "zonehash(bytes32)": {
        "details": "Obtains the hash for the zone.",
        "params": {
          "node": "The INS node to query."
        },
        "returns": {
          "_0": "The associated contenthash."
        }
      }
    },
    "events": {
      "ABIChanged(bytes32,uint256)": {
        "details": "Emitted when the ABI is changed."
      },
      "AddrChanged(bytes32,address)": {
        "details": "Emitted when an address of a node is changed."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "See {IERC1155-ApprovalForAll}. Logged when an operator is added or removed."
      },
      "Approved(address,bytes32,address,bool)": {
        "details": "Logged when a delegate is approved or an approval is revoked."
      },
      "ContentHashChanged(bytes32,bytes)": {
        "details": "Emitted when the content hash of a node is changed."
      },
      "DNSRecordChanged(bytes32,bytes,uint16,bytes)": {
        "details": "Emitted whenever a given node/name/resource's RRSET is updated."
      },
      "DNSRecordDeleted(bytes32,bytes,uint16)": {
        "details": "Emitted whenever a given node/name/resource's RRSET is deleted."
      },
      "DNSZonehashChanged(bytes32,bytes,bytes)": {
        "details": "Emitted whenever a given node's zone hash is updated."
      },
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "InterfaceChanged(bytes32,bytes4,address)": {
        "details": "Emitted when the interface of node is changed."
      },
      "NameChanged(bytes32,string)": {
        "details": "Emitted when a node name is changed."
      },
      "PubkeyChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when a node public key is changed."
      },
      "TextChanged(bytes32,string,string,string)": {
        "details": "Emitted when a node text is changed."
      },
      "VersionChanged(bytes32,uint64)": {
        "details": "Emitted when the version of a node is changed."
      }
    },
    "title": "Public Resolver"
  },
  "isFoundry": true,
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidContentType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"}],\"name\":\"ABIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContentHashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"record\",\"type\":\"bytes\"}],\"name\":\"DNSRecordChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"DNSRecordDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lastzonehash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zonehash\",\"type\":\"bytes\"}],\"name\":\"DNSZonehashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"PubkeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newVersion\",\"type\":\"uint64\"}],\"name\":\"VersionChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentTypes\",\"type\":\"uint256\"}],\"name\":\"ABI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"clearRecords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contentHash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"dnsRecord\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRNSUnified\",\"outputs\":[{\"internalType\":\"contract INSUnified\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReverseRegistrar\",\"outputs\":[{\"internalType\":\"contract INSReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"hasDNSRecords\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract INSUnified\",\"name\":\"rnsUnified\",\"type\":\"address\"},{\"internalType\":\"contract INSReverseRegistrar\",\"name\":\"reverseRegistrar\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"interfaceImplementer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicallWithNodeCheck\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"pubkey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"recordVersions\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setABI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContentHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setDNSRecords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"setPubkey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setZonehash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"requireSuccess\",\"type\":\"bool\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"tryMulticall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"zonehash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A simple resolver anyone can use, only allows the owner of a node to set its address.\",\"events\":{\"ABIChanged(bytes32,uint256)\":{\"details\":\"Emitted when the ABI is changed.\"},\"AddrChanged(bytes32,address)\":{\"details\":\"Emitted when an address of a node is changed.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"See {IERC1155-ApprovalForAll}. Logged when an operator is added or removed.\"},\"Approved(address,bytes32,address,bool)\":{\"details\":\"Logged when a delegate is approved or an approval is revoked.\"},\"ContentHashChanged(bytes32,bytes)\":{\"details\":\"Emitted when the content hash of a node is changed.\"},\"DNSRecordChanged(bytes32,bytes,uint16,bytes)\":{\"details\":\"Emitted whenever a given node/name/resource's RRSET is updated.\"},\"DNSRecordDeleted(bytes32,bytes,uint16)\":{\"details\":\"Emitted whenever a given node/name/resource's RRSET is deleted.\"},\"DNSZonehashChanged(bytes32,bytes,bytes)\":{\"details\":\"Emitted whenever a given node's zone hash is updated.\"},\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"InterfaceChanged(bytes32,bytes4,address)\":{\"details\":\"Emitted when the interface of node is changed.\"},\"NameChanged(bytes32,string)\":{\"details\":\"Emitted when a node name is changed.\"},\"PubkeyChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when a node public key is changed.\"},\"TextChanged(bytes32,string,string,string)\":{\"details\":\"Emitted when a node text is changed.\"},\"VersionChanged(bytes32,uint64)\":{\"details\":\"Emitted when the version of a node is changed.\"}},\"kind\":\"dev\",\"methods\":{\"ABI(bytes32,uint256)\":{\"details\":\"Returns the ABI associated with an INS node. Defined in EIP-205, see more at https://eips.ethereum.org/EIPS/eip-205\",\"params\":{\"contentTypes\":\"A bitwise OR of the ABI formats accepted by the caller.\",\"node\":\"The INS node to query\"},\"returns\":{\"_0\":\"The content type of the return value\",\"_1\":\"The ABI data\"}},\"addr(bytes32)\":{\"details\":\"Override {IAddressResolvable-addr}.\"},\"clearRecords(bytes32)\":{\"details\":\"Increments the record version associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {VersionChanged}.\",\"params\":{\"node\":\"The node to update.\"}},\"contentHash(bytes32)\":{\"details\":\"Returns the content hash associated with an INS node.\",\"params\":{\"node\":\"The INS node to query.\"},\"returns\":{\"_0\":\"The associated content hash.\"}},\"dnsRecord(bytes32,bytes32,uint16)\":{\"details\":\"Obtain a DNS record.\",\"params\":{\"name\":\"the keccak-256 hash of the fully-qualified name for which to fetch the record\",\"node\":\"the namehash of the node for which to fetch the record\",\"resource\":\"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\"},\"returns\":{\"_0\":\"the DNS record in wire format if present, otherwise empty\"}},\"getRNSUnified()\":{\"details\":\"Retrieves the RNSUnified associated with this resolver.\"},\"getReverseRegistrar()\":{\"details\":\"Retrieves the reverse registrar associated with this resolver.\"},\"hasDNSRecords(bytes32,bytes32)\":{\"details\":\"Checks whether a given node has records.\",\"params\":{\"name\":\"the namehash of the node for which to check the records\",\"node\":\"the namehash of the node for which to check the records\"}},\"interfaceImplementer(bytes32,bytes4)\":{\"details\":\"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned.\",\"params\":{\"interfaceID\":\"The EIP 165 interface ID to check for.\",\"node\":\"The INS node to query.\"},\"returns\":{\"_0\":\"The address that implements this interface, or 0 if the interface is unsupported.\"}},\"isAuthorized(bytes32,address)\":{\"details\":\"Checks if an account is authorized to manage the resolution of a specific RNS node.\",\"params\":{\"account\":\"The account address being checked for authorization.\",\"node\":\"The RNS node.\"},\"returns\":{\"authorized\":\"A boolean indicating whether the account is authorized.\"}},\"multicall(bytes[])\":{\"details\":\"Executes bulk action to the original contract. Reverts if there is a single call failed.\",\"params\":{\"data\":\"The calldata to original contract.\"}},\"multicallWithNodeCheck(bytes32,bytes[])\":{\"details\":\"This function provides an extra security check when called from privileged contracts (such as RONRegistrarController) that can set records on behalf of the node owners. Reverts if the node is not null but calldata is mismatched.\"},\"name(bytes32)\":{\"details\":\"Override {INameResolver-name}.\"},\"pubkey(bytes32)\":{\"details\":\"See {IPublicKeyResolver-pubkey}.\"},\"recordVersions(bytes32)\":{\"details\":\"Returns the latest version of a node.\"},\"setABI(bytes32,uint256,bytes)\":{\"details\":\"Sets the ABI associated with an INS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. - The content type must be powers of 2. Emitted an event {ABIChanged}.\",\"params\":{\"contentType\":\"The content type of the ABI\",\"data\":\"The ABI data.\",\"node\":\"The node to update.\"}},\"setAddr(bytes32,address)\":{\"details\":\"Sets the address associated with an INS node. Requirement: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {AddrChanged}.\",\"params\":{\"addr\":\"The address to set.\",\"node\":\"The node to update.\"}},\"setContentHash(bytes32,bytes)\":{\"details\":\"Sets the content hash associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {ContentHashChanged}.\",\"params\":{\"hash\":\"The content hash to set\",\"node\":\"The node to update.\"}},\"setDNSRecords(bytes32,bytes)\":{\"details\":\"Set one or more DNS records.  Records are supplied in wire-format.  Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:   a.example.com IN A 1.2.3.4   a.example.com IN A 5.6.7.8   www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:   a.example.com IN A 1.2.3.4   www.example.com IN CNAME a.example.com.   a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}.\",\"params\":{\"data\":\"the DNS wire format records to set\",\"node\":\"the namehash of the node for which to set the records\"}},\"setInterface(bytes32,bytes4,address)\":{\"details\":\"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}.\",\"params\":{\"implementer\":\"The address of a contract that implements this interface for this node.\",\"interfaceID\":\"The EIP 165 interface ID.\",\"node\":\"The node to update.\"}},\"setName(bytes32,string)\":{\"details\":\"Sets the name associated with an INS node, for reverse records. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {NameChanged}.\",\"params\":{\"node\":\"The node to update.\"}},\"setPubkey(bytes32,bytes32,bytes32)\":{\"details\":\"Sets the SECP256k1 public key associated with an INS node. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {PubkeyChanged}.\",\"params\":{\"node\":\"The INS node to query\",\"x\":\"the X coordinate of the curve point for the public key.\",\"y\":\"the Y coordinate of the curve point for the public key.\"}},\"setText(bytes32,string,string)\":{\"details\":\"Sets the text data associated with an INS node and key. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {TextChanged}.\",\"params\":{\"key\":\"The key to set.\",\"node\":\"The node to update.\",\"value\":\"The text data value to set.\"}},\"setZonehash(bytes32,bytes)\":{\"details\":\"Sets the hash for the zone. Requirements: - The method caller must be authorized to change user fields of RNS Token `node`. See indicator {ModifyingIndicator.USER_FIELDS_INDICATOR}. Emits an event {DNSZonehashChanged}.\",\"params\":{\"hash\":\"The zonehash to set\",\"node\":\"The node to update.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Override {IERC165-supportsInterface}.\"},\"text(bytes32,string)\":{\"params\":{\"key\":\"The text data key to query.\",\"node\":\"The INS node to query.\"},\"returns\":{\"_0\":\"The associated text data.\"}},\"tryMulticall(bool,bytes[])\":{\"details\":\"Executes bulk action to the original contract.\",\"params\":{\"data\":\"The calldata to original contract.\",\"requireSuccess\":\"Flag to indicating whether the contract reverts if there is a single call failed.\"}},\"zonehash(bytes32)\":{\"details\":\"Obtains the hash for the zone.\",\"params\":{\"node\":\"The INS node to query.\"},\"returns\":{\"_0\":\"The associated contenthash.\"}}},\"stateVariables\":{\"____gap\":{\"details\":\"Gap for upgradeability.\"},\"_reverseRegistrar\":{\"details\":\"The reverse registrar contract\"},\"_rnsUnified\":{\"details\":\"The RNS Unified contract\"}},\"title\":\"Public Resolver\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidContentType()\":[{\"notice\":\"Thrown when the input content type is invalid.\"}]},\"kind\":\"user\",\"methods\":{\"text(bytes32,string)\":{\"notice\":\"Returns the text data associated with an INS node and key.\"}},\"notice\":\"Customized version of PublicResolver: https://github.com/ensdomains/ens-contracts/blob/0c75ba23fae76165d51c9c80d76d22261e06179d/contracts/resolvers/PublicResolver.sol\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/resolvers/PublicResolver.sol\":\"PublicResolver\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@ensdomains/buffer/=lib/buffer/\",\":@ensdomains/ens-contracts/=lib/ens-contracts/contracts/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@pythnetwork/=lib/pyth-sdk-solidity/\",\":@rns-contracts/=src/\",\":buffer/=lib/buffer/contracts/\",\":contract-template/=lib/contract-template/src/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":ens-contracts/=lib/ens-contracts/contracts/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":foundry-deployment-kit/=lib/foundry-deployment-kit/script/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts/contracts/\",\":pyth-sdk-solidity/=lib/pyth-sdk-solidity/\",\":solady/=lib/solady/src/\"]},\"sources\":{\"lib/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd6dd3b0b327288f8e1b711a609f4040fea602e2ad4bba9febdf2f33b4e56eb0c\",\"license\":\"BSD-2-Clause\"},\"lib/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary BytesUtils {\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two bytes are equal.\\n     * @param self The first bytes to compare.\\n     * @param other The second bytes to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (int256) {\\n        return compare(self, 0, self.length, other, 0, other.length);\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first bytes to compare.\\n     * @param offset The offset of self.\\n     * @param len    The length of self.\\n     * @param other The second bytes to compare.\\n     * @param otheroffset The offset of the other string.\\n     * @param otherlen    The length of the other string.\\n     * @return The result of the comparison.\\n     */\\n    function compare(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len,\\n        bytes memory other,\\n        uint256 otheroffset,\\n        uint256 otherlen\\n    ) internal pure returns (int256) {\\n        if (offset + len > self.length) {\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\n        }\\n        if (otheroffset + otherlen > other.length) {\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\n        }\\n\\n        uint256 shortest = len;\\n        if (otherlen < len) shortest = otherlen;\\n\\n        uint256 selfptr;\\n        uint256 otherptr;\\n\\n        assembly {\\n            selfptr := add(self, add(offset, 32))\\n            otherptr := add(other, add(otheroffset, 32))\\n        }\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\n            uint256 a;\\n            uint256 b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask;\\n                if (shortest - idx >= 32) {\\n                    mask = type(uint256).max;\\n                } else {\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\n                }\\n                int256 diff = int256(a & mask) - int256(b & mask);\\n                if (diff != 0) return diff;\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n\\n        return int256(len) - int256(otherlen);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @param otherOffset The offset into the second byte range.\\n     * @param len The number of bytes to compare\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other,\\n        uint256 otherOffset,\\n        uint256 len\\n    ) internal pure returns (bool) {\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @param otherOffset The offset into the second byte range.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other,\\n        uint256 otherOffset\\n    ) internal pure returns (bool) {\\n        return\\n            keccak(self, offset, self.length - offset) ==\\n            keccak(other, otherOffset, other.length - otherOffset);\\n    }\\n\\n    /*\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\n     *      they are equal.\\n     * @param self The first byte range to compare.\\n     * @param offset The offset into the first byte range.\\n     * @param other The second byte range to compare.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        uint256 offset,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        return\\n            self.length == offset + other.length &&\\n            equals(self, offset, other, 0, other.length);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two byte ranges are equal.\\n     * @param self The first byte range to compare.\\n     * @param other The second byte range to compare.\\n     * @return True if the byte ranges are equal, false otherwise.\\n     */\\n    function equals(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        return\\n            self.length == other.length &&\\n            equals(self, 0, other, 0, self.length);\\n    }\\n\\n    /*\\n     * @dev Returns the 8-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\n     */\\n    function readUint8(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (uint8 ret) {\\n        return uint8(self[idx]);\\n    }\\n\\n    /*\\n     * @dev Returns the 16-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\n     */\\n    function readUint16(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (uint16 ret) {\\n        require(idx + 2 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32-bit number at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\n     */\\n    function readUint32(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (uint32 ret) {\\n        require(idx + 4 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32 byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytes32(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes32 ret) {\\n        require(idx + 32 <= self.length);\\n        assembly {\\n            ret := mload(add(add(self, 32), idx))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the 32 byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytes20(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes20 ret) {\\n        require(idx + 20 <= self.length);\\n        assembly {\\n            ret := and(\\n                mload(add(add(self, 32), idx)),\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns the n byte value at the specified index of self.\\n     * @param self The byte string.\\n     * @param idx The index into the bytes.\\n     * @param len The number of bytes.\\n     * @return The specified 32 bytes of the string.\\n     */\\n    function readBytesN(\\n        bytes memory self,\\n        uint256 idx,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(len <= 32);\\n        require(idx + len <= self.length);\\n        assembly {\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\n        }\\n    }\\n\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint256 mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Copies a substring into a new byte string.\\n     * @param self The byte string to copy from.\\n     * @param offset The offset to start copying at.\\n     * @param len The number of bytes to copy.\\n     */\\n    function substring(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes memory) {\\n        require(offset + len <= self.length);\\n\\n        bytes memory ret = new bytes(len);\\n        uint256 dest;\\n        uint256 src;\\n\\n        assembly {\\n            dest := add(ret, 32)\\n            src := add(add(self, 32), offset)\\n        }\\n        memcpy(dest, src, len);\\n\\n        return ret;\\n    }\\n\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\n    // 0xFF represents invalid characters in that range.\\n    bytes constant base32HexTable =\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\n\\n    /**\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\n     * @param self The data to decode.\\n     * @param off Offset into the string to start at.\\n     * @param len Number of characters to decode.\\n     * @return The decoded data, left aligned.\\n     */\\n    function base32HexDecodeWord(\\n        bytes memory self,\\n        uint256 off,\\n        uint256 len\\n    ) internal pure returns (bytes32) {\\n        require(len <= 52);\\n\\n        uint256 ret = 0;\\n        uint8 decoded;\\n        for (uint256 i = 0; i < len; i++) {\\n            bytes1 char = self[off + i];\\n            require(char >= 0x30 && char <= 0x7A);\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\n            require(decoded <= 0x20);\\n            if (i == len - 1) {\\n                break;\\n            }\\n            ret = (ret << 5) | decoded;\\n        }\\n\\n        uint256 bitlen = len * 5;\\n        if (len % 8 == 0) {\\n            // Multiple of 8 characters, no padding\\n            ret = (ret << 5) | decoded;\\n        } else if (len % 8 == 2) {\\n            // Two extra characters - 1 byte\\n            ret = (ret << 3) | (decoded >> 2);\\n            bitlen -= 2;\\n        } else if (len % 8 == 4) {\\n            // Four extra characters - 2 bytes\\n            ret = (ret << 1) | (decoded >> 4);\\n            bitlen -= 4;\\n        } else if (len % 8 == 5) {\\n            // Five extra characters - 3 bytes\\n            ret = (ret << 4) | (decoded >> 1);\\n            bitlen -= 1;\\n        } else if (len % 8 == 7) {\\n            // Seven extra characters - 4 bytes\\n            ret = (ret << 2) | (decoded >> 3);\\n            bitlen -= 3;\\n        } else {\\n            revert();\\n        }\\n\\n        return bytes32(ret << (256 - bitlen));\\n    }\\n\\n    /**\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\n     * @param self The string to search\\n     * @param off The offset to start searching at\\n     * @param len The number of bytes to search\\n     * @param needle The byte to search for\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\n     */\\n    function find(\\n        bytes memory self,\\n        uint256 off,\\n        uint256 len,\\n        bytes1 needle\\n    ) internal pure returns (uint256) {\\n        for (uint256 idx = off; idx < off + len; idx++) {\\n            if (self[idx] == needle) {\\n                return idx;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n}\\n\",\"keccak256\":\"0x4f10902639b85a17ae10745264feff322e793bfb1bc130a9a90efa7dda47c6cc\"},\"lib/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\n */\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /**\\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return The length of the DNS name at 'offset', in bytes.\\n     */\\n    function nameLength(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint256 labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /**\\n     * @dev Returns a DNS format name at the specified offset of self.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return ret The name.\\n     */\\n    function readName(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes memory ret) {\\n        uint256 len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /**\\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n     * @param self The byte array to read a name from.\\n     * @param offset The offset to start reading at.\\n     * @return The number of labels in the DNS name at 'offset', in bytes.\\n     */\\n    function labelCount(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint256 labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint256 constant RRSIG_TYPE = 0;\\n    uint256 constant RRSIG_ALGORITHM = 2;\\n    uint256 constant RRSIG_LABELS = 3;\\n    uint256 constant RRSIG_TTL = 4;\\n    uint256 constant RRSIG_EXPIRATION = 8;\\n    uint256 constant RRSIG_INCEPTION = 12;\\n    uint256 constant RRSIG_KEY_TAG = 16;\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(\\n        bytes memory data\\n    ) internal pure returns (SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\n        );\\n    }\\n\\n    function rrs(\\n        SignedSet memory rrset\\n    ) internal pure returns (RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /**\\n     * @dev An iterator over resource records.\\n     */\\n    struct RRIterator {\\n        bytes data;\\n        uint256 offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint256 rdataOffset;\\n        uint256 nextOffset;\\n    }\\n\\n    /**\\n     * @dev Begins iterating over resource records.\\n     * @param self The byte string to read from.\\n     * @param offset The offset to start reading at.\\n     * @return ret An iterator object.\\n     */\\n    function iterateRRs(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /**\\n     * @dev Returns true iff there are more RRs to iterate.\\n     * @param iter The iterator to check.\\n     * @return True iff the iterator has finished.\\n     */\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /**\\n     * @dev Moves the iterator to the next resource record.\\n     * @param iter The iterator to advance.\\n     */\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint256 rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the current record.\\n     * @param iter The iterator.\\n     * @return A new bytes object containing the owner name from the RR.\\n     */\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.offset,\\n                nameLength(iter.data, iter.offset)\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the rdata portion of the current record.\\n     * @param iter The iterator.\\n     * @return A new bytes object containing the RR's RDATA.\\n     */\\n    function rdata(\\n        RRIterator memory iter\\n    ) internal pure returns (bytes memory) {\\n        return\\n            iter.data.substring(\\n                iter.rdataOffset,\\n                iter.nextOffset - iter.rdataOffset\\n            );\\n    }\\n\\n    uint256 constant DNSKEY_FLAGS = 0;\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\n    uint256 constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(\\n            offset + DNSKEY_PUBKEY,\\n            length - DNSKEY_PUBKEY\\n        );\\n    }\\n\\n    uint256 constant DS_KEY_TAG = 0;\\n    uint256 constant DS_ALGORITHM = 2;\\n    uint256 constant DS_DIGEST_TYPE = 3;\\n    uint256 constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 length\\n    ) internal pure returns (DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    function isSubdomainOf(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (bool) {\\n        uint256 off = 0;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        while (counts > othercounts) {\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        return self.equals(off, other, 0);\\n    }\\n\\n    function compareNames(\\n        bytes memory self,\\n        bytes memory other\\n    ) internal pure returns (int256) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint256 off;\\n        uint256 otheroff;\\n        uint256 prevoff;\\n        uint256 otherprevoff;\\n        uint256 counts = labelCount(self, 0);\\n        uint256 othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if (otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return\\n            self.compare(\\n                prevoff + 1,\\n                self.readUint8(prevoff),\\n                other,\\n                otherprevoff + 1,\\n                other.readUint8(otherprevoff)\\n            );\\n    }\\n\\n    /**\\n     * @dev Compares two serial numbers using RFC1982 serial number math.\\n     */\\n    function serialNumberGte(\\n        uint32 i1,\\n        uint32 i2\\n    ) internal pure returns (bool) {\\n        unchecked {\\n            return int32(i1) - int32(i2) >= 0;\\n        }\\n    }\\n\\n    function progress(\\n        bytes memory body,\\n        uint256 off\\n    ) internal pure returns (uint256) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n\\n    /**\\n     * @dev Computes the keytag for a chunk of data.\\n     * @param data The data to compute a keytag for.\\n     * @return The computed key tag.\\n     */\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n        /* This function probably deserves some explanation.\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\\n         *\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\n         *         uint ac;\\n         *         for (uint i = 0; i < data.length; i++) {\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\n         *         }\\n         *         return uint16(ac + (ac >> 16));\\n         *     }\\n         *\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\\n         * large words work in our favour.\\n         *\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\n         *\\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\\n         * and the remaining sums can be done just on ac1.\\n         */\\n        unchecked {\\n            require(data.length <= 8192, \\\"Long keys not permitted\\\");\\n            uint256 ac1;\\n            uint256 ac2;\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(add(add(data, 32), i))\\n                }\\n                if (i + 32 > data.length) {\\n                    uint256 unused = 256 - (data.length - i) * 8;\\n                    word = (word >> unused) << unused;\\n                }\\n                ac1 +=\\n                    (word &\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\n                    8;\\n                ac2 += (word &\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\n            }\\n            ac1 =\\n                (ac1 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac1 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac2 =\\n                (ac2 &\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\n                ((ac2 &\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\n                    16);\\n            ac1 = (ac1 << 8) + ac2;\\n            ac1 =\\n                (ac1 &\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\n                    32);\\n            ac1 =\\n                (ac1 &\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\n                ((ac1 &\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\n                    64);\\n            ac1 =\\n                (ac1 &\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\n                (ac1 >> 128);\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\n            return uint16(ac1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4dd68a6efd7c38f6b0e95ca0c056ecb74f88583da650b1a8639e6e78be36fede\"},\"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/access/IAccessControlEnumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xba4459ab871dfa300f5212c6c30178b63898c03533a1ede28436f11546626676\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x3d6069be9b4c01fb81840fb9c2c4dc58dd6a6a4aafaa2c6837de8699574d84c6\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"src/extensions/Multicallable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ERC165 } from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport { IMulticallable } from \\\"../interfaces/IMulticallable.sol\\\";\\nimport { ErrorHandler } from \\\"../libraries/ErrorHandler.sol\\\";\\n\\nabstract contract Multicallable is ERC165, IMulticallable {\\n  using ErrorHandler for bool;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n    return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IMulticallable\\n   */\\n  function multicall(bytes[] calldata data) public override returns (bytes[] memory results) {\\n    return _tryMulticall(true, data);\\n  }\\n\\n  /**\\n   * @inheritdoc IMulticallable\\n   */\\n  function tryMulticall(bool requireSuccess, bytes[] calldata data) public override returns (bytes[] memory results) {\\n    return _tryMulticall(requireSuccess, data);\\n  }\\n\\n  /**\\n   * @dev See {IMulticallable-tryMulticall}.\\n   */\\n  function _tryMulticall(bool requireSuccess, bytes[] calldata data) internal returns (bytes[] memory results) {\\n    uint256 length = data.length;\\n    results = new bytes[](length);\\n\\n    bool success;\\n    bytes memory result;\\n\\n    for (uint256 i; i < length;) {\\n      (success, result) = address(this).delegatecall(data[i]);\\n      if (requireSuccess) success.handleRevert(result);\\n      results[i] = result;\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x70872947f6c70988ee36af335bf872338b55ca71d8ea3c92dcb153ec5d05bc21\",\"license\":\"MIT\"},\"src/interfaces/IMulticallable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice To multi-call to a specified contract which has multicall interface:\\n *\\n * ```solidity\\n * interface IMock is IMulticallable {\\n *   function foo() external;\\n *   function bar() external;\\n * }\\n *\\n * bytes[] memory calldatas = new bytes[](2);\\n * calldatas[0] = abi.encodeCall(IMock.foo,());\\n * calldatas[1] = abi.encodeCall(IMock.bar,());\\n * IMock(target).multicall(calldatas);\\n * ```\\n */\\ninterface IMulticallable {\\n  /**\\n   * @dev Executes bulk action to the original contract.\\n   * Reverts if there is a single call failed.\\n   *\\n   * @param data The calldata to original contract.\\n   *\\n   */\\n  function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n\\n  /**\\n   * @dev Executes bulk action to the original contract.\\n   *\\n   * @param requireSuccess Flag to indicating whether the contract reverts if there is a single call failed.\\n   * @param data The calldata to original contract.\\n   *\\n   */\\n  function tryMulticall(bool requireSuccess, bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x0e76578b0efeafdf33915d77d3f98145ac2f74cdd311db03a9b94d4aa566d107\",\"license\":\"UNLICENSED\"},\"src/interfaces/INSReverseRegistrar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport { INameResolver } from \\\"./resolvers/INameResolver.sol\\\";\\nimport { INSUnified } from \\\"./INSUnified.sol\\\";\\n\\n/// @dev See https://eips.ethereum.org/EIPS/eip-181#registrar\\ninterface IERC181 {\\n  /**\\n   * @dev Claims the name hex(addr) + '.addr.reverse' for addr.\\n   *\\n   * @param addr The address to set as the addr of the reverse record in INS.\\n   * @return id The INS node hash of the reverse record.\\n   */\\n  function claim(address addr) external returns (uint256 id);\\n\\n  /**\\n   * @dev Claims the name hex(owner) + '.addr.reverse' for owner and sets resolver.\\n   *\\n   * @param addr The address to set as the owner of the reverse record in INS.\\n   * @param resolver The address of the resolver to set; 0 to leave unchanged.\\n   * @return id The INS node hash of the reverse record.\\n   */\\n  function claimWithResolver(address addr, address resolver) external returns (uint256 id);\\n\\n  /**\\n   * @dev Sets the name record for the reverse INS record associated with the calling account. First updates the\\n   * resolver to the default reverse resolver if necessary.\\n   *\\n   * @param name The name to set for this address.\\n   * @return The INS node hash of the reverse record.\\n   */\\n  function setName(string memory name) external returns (uint256);\\n}\\n\\ninterface INSReverseRegistrar is IERC181, IERC165 {\\n  /// @dev Error: The provided id is not child node of `ADDR_REVERSE_ID`\\n  error InvalidId();\\n  /// @dev Error: The contract is not authorized for minting or modifying domain hex(addr) + '.addr.reverse'.\\n  error InvalidConfig();\\n  /// @dev Error: The sender lacks the necessary permissions.\\n  error Unauthorized();\\n  /// @dev Error: The provided resolver address is null.\\n  error NullAssignment();\\n\\n  /// @dev Emitted when reverse node is claimed.\\n  event ReverseClaimed(address indexed addr, uint256 indexed id);\\n  /// @dev Emitted when the default resolver is changed.\\n  event DefaultResolverChanged(INameResolver indexed resolver);\\n\\n  /**\\n   * @dev Returns the controller role.\\n   */\\n  function CONTROLLER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @dev Returns default resolver.\\n   */\\n  function getDefaultResolver() external view returns (INameResolver);\\n\\n  /**\\n   * @dev Returns RNSUnified contract.\\n   */\\n  function getRNSUnified() external view returns (INSUnified);\\n\\n  /**\\n   * @dev Sets default resolver.\\n   *\\n   * Requirement:\\n   *\\n   * - The method caller must be admin.\\n   *\\n   * Emitted an event {DefaultResolverChanged}.\\n   *\\n   */\\n  function setDefaultResolver(INameResolver resolver) external;\\n\\n  /**\\n   * @dev Same as {IERC181-setName}.\\n   */\\n  function setNameForAddr(address addr, string memory name) external returns (uint256 id);\\n\\n  /**\\n   * @dev Returns address that the reverse node resolves for.\\n   * Eg. node namehash('{addr}.addr.reverse') will always resolve for `addr`.\\n   */\\n  function getAddress(uint256 id) external view returns (address);\\n\\n  /**\\n   * @dev Returns the id hash for a given account's reverse records.\\n   * @param addr The address to hash\\n   * @return The INS node hash.\\n   */\\n  function computeId(address addr) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0x3b88e9ea1dd7c128244b5d0c69cee9dcadcb16b05a7e13416cc7b95c071b60a4\",\"license\":\"MIT\"},\"src/interfaces/INSUnified.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { IERC721Metadata } from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport { IAccessControlEnumerable } from \\\"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\\\";\\nimport { ModifyingIndicator } from \\\"../types/ModifyingIndicator.sol\\\";\\n\\ninterface INSUnified is IAccessControlEnumerable, IERC721Metadata {\\n  /// @dev Error: The provided token id is expired.\\n  error Expired();\\n  /// @dev Error: The provided token id is unexists.\\n  error Unexists();\\n  /// @dev Error: The provided id expiry is greater than parent id expiry.\\n  error ExceedParentExpiry();\\n  /// @dev Error: The provided name is unavailable for registration.\\n  error Unavailable();\\n  /// @dev Error: The sender lacks the necessary permissions.\\n  error Unauthorized();\\n  /// @dev Error: Missing controller role required for modification.\\n  error MissingControllerRole();\\n  /// @dev Error: Attempting to set an immutable field, which cannot be modified.\\n  error CannotSetImmutableField();\\n  /// @dev Error: Missing protected settler role required for modification.\\n  error MissingProtectedSettlerRole();\\n  /// @dev Error: Attempting to set an expiry time that is not larger than the previous one.\\n  error ExpiryTimeMustBeLargerThanTheOldOne();\\n  /// @dev Error: The provided name must be registered or is in a grace period.\\n  error NameMustBeRegisteredOrInGracePeriod();\\n\\n  /**\\n   * | Fields\\\\Idc | Modifying Indicator |\\n   * | ---------- | ------------------- |\\n   * | depth      | 0b00000001          |\\n   * | parentId   | 0b00000010          |\\n   * | label      | 0b00000100          |\\n   */\\n  struct ImmutableRecord {\\n    // The level-th of a domain.\\n    uint8 depth;\\n    // The node of parent token. Eg, parent node of vip.duke.ron equals to namehash('duke.ron')\\n    uint256 parentId;\\n    // The label of a domain. Eg, label is vip for domain vip.duke.ron\\n    string label;\\n  }\\n\\n  /**\\n   * | Fields\\\\Idc,Roles | Modifying Indicator | Controller | Protected setter | (Parent) Owner/Spender |\\n   * | ---------------- | ------------------- | ---------- | ---------------- | ---------------------- |\\n   * | resolver         | 0b00001000          | x          |                  | x                      |\\n   * | owner            | 0b00010000          | x          |                  | x                      |\\n   * | expiry           | 0b00100000          | x          |                  |                        |\\n   * | protected        | 0b01000000          |            | x                |                        |\\n   * Note: (Parent) Owner/Spender means parent owner or current owner or current token spender.\\n   */\\n  struct MutableRecord {\\n    // The resolver address.\\n    address resolver;\\n    // The record owner. This field must equal to the owner of token.\\n    address owner;\\n    // Expiry timestamp.\\n    uint64 expiry;\\n    // Flag indicating whether the token is protected or not.\\n    bool protected;\\n  }\\n\\n  struct Record {\\n    ImmutableRecord immut;\\n    MutableRecord mut;\\n  }\\n\\n  /// @dev Emitted when a base URI is updated.\\n  event BaseURIUpdated(address indexed operator, string newURI);\\n  /// @dev Emitted when the grace period for all domain is updated.\\n  event GracePeriodUpdated(address indexed operator, uint64 newGracePeriod);\\n\\n  /**\\n   * @dev Emitted when the record of node is updated.\\n   * @param indicator The binary index of updated fields. Eg, 0b10101011 means fields at position 1, 2, 4, 6, 8 (right\\n   * to left) needs to be updated.\\n   * @param record The updated fields.\\n   */\\n  event RecordUpdated(uint256 indexed node, ModifyingIndicator indicator, Record record);\\n\\n  /**\\n   * @dev Returns the controller role.\\n   * @notice Can set all fields {Record.mut} in token record, excepting {Record.mut.protected}.\\n   */\\n  function CONTROLLER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @dev Returns the protected setter role.\\n   * @notice Can set field {Record.mut.protected} in token record by using method `bulkSetProtected`.\\n   */\\n  function PROTECTED_SETTLER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @dev Returns the reservation role.\\n   * @notice Never expire for token owner has this role.\\n   */\\n  function RESERVATION_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @dev Returns the max expiry value.\\n   */\\n  function MAX_EXPIRY() external pure returns (uint64);\\n\\n  /**\\n   * @dev Returns the name hash output of a domain.\\n   */\\n  function namehash(string memory domain) external pure returns (bytes32 node);\\n\\n  /**\\n   * @dev Returns true if the specified name is available for registration.\\n   * Note: Only available after passing the grace period.\\n   */\\n  function available(uint256 id) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the grace period in second(s).\\n   * Note: This period affects the availability of the domain.\\n   */\\n  function getGracePeriod() external view returns (uint64);\\n\\n  /**\\n   * @dev Returns the total minted ids.\\n   * Note: Burning id will not affect `totalMinted`.\\n   */\\n  function totalMinted() external view returns (uint256);\\n\\n  /**\\n   * @dev Sets the grace period in second(s).\\n   *\\n   * Requirements:\\n   * - The method caller must have controller role.\\n   *\\n   * Note: This period affects the availability of the domain.\\n   */\\n  function setGracePeriod(uint64) external;\\n\\n  /**\\n   * @dev Sets the base uri.\\n   *\\n   * Requirements:\\n   * - The method caller must be contract owner.\\n   *\\n   */\\n  function setBaseURI(string calldata baseTokenURI) external;\\n\\n  /**\\n   * @dev Mints token for subnode.\\n   *\\n   * Requirements:\\n   * - The token must be available.\\n   * - The method caller must be (parent) owner or approved spender. See struct {MutableRecord}.\\n   *\\n   * Emits an event {RecordUpdated}.\\n   *\\n   * @param parentId The parent node to mint or create subnode.\\n   * @param label The domain label. Eg, label is duke for domain duke.ron.\\n   * @param resolver The resolver address.\\n   * @param owner The token owner.\\n   * @param duration Duration in second(s) to expire. Leave 0 to set as parent.\\n   */\\n  function mint(uint256 parentId, string calldata label, address resolver, address owner, uint64 duration)\\n    external\\n    returns (uint64 expiryTime, uint256 id);\\n\\n  /**\\n   * @dev Returns all record of a domain.\\n   * Reverts if the token is non existent.\\n   */\\n  function getRecord(uint256 id) external view returns (Record memory record);\\n\\n  /**\\n   * @dev Returns the domain name of id.\\n   */\\n  function getDomain(uint256 id) external view returns (string memory domain);\\n\\n  /**\\n   * @dev Returns whether the requester is able to modify the record based on the updated index.\\n   * Note: This method strictly follows the permission of struct {MutableRecord}.\\n   */\\n  function canSetRecord(address requester, uint256 id, ModifyingIndicator indicator)\\n    external\\n    view\\n    returns (bool, bytes4 error);\\n\\n  /**\\n   * @dev Sets record of existing token. Update operation for {Record.mut}.\\n   *\\n   * Requirements:\\n   * - The method caller must have role based on the corresponding `indicator`. See struct {MutableRecord}.\\n   *\\n   * Emits an event {RecordUpdated}.\\n   */\\n  function setRecord(uint256 id, ModifyingIndicator indicator, MutableRecord calldata record) external;\\n\\n  /**\\n   * @dev Reclaims ownership. Update operation for {Record.mut.owner}.\\n   *\\n   * Requirements:\\n   * - The method caller should have controller role.\\n   * - The method caller should be (parent) owner or approved spender. See struct {MutableRecord}.\\n   *\\n   * Emits an event {RecordUpdated}.\\n   */\\n  function reclaim(uint256 id, address owner) external;\\n\\n  /**\\n   * @dev Renews token. Update operation for {Record.mut.expiry}.\\n   *\\n   * Requirements:\\n   * - The method caller should have controller role.\\n   *\\n   * Emits an event {RecordUpdated}.\\n   */\\n  function renew(uint256 id, uint64 duration) external returns (uint64 expiry);\\n\\n  /**\\n   * @dev Sets expiry time for a token. Update operation for {Record.mut.expiry}.\\n   *\\n   * Requirements:\\n   * - The method caller must have controller role.\\n   *\\n   * Emits an event {RecordUpdated}.\\n   */\\n  function setExpiry(uint256 id, uint64 expiry) external;\\n\\n  /**\\n   * @dev Sets the protected status of a list of ids. Update operation for {Record.mut.protected}.\\n   *\\n   * Requirements:\\n   * - The method caller must have protected setter role.\\n   *\\n   * Emits events {RecordUpdated}.\\n   */\\n  function bulkSetProtected(uint256[] calldata ids, bool protected) external;\\n}\\n\",\"keccak256\":\"0xaef1c58bb7c8688d6677a1c2739c0dc9e645ca5c64dd875be2f2b7a318a11406\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IABIResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IABIResolver {\\n  /// Thrown when the input content type is invalid.\\n  error InvalidContentType();\\n\\n  /// @dev Emitted when the ABI is changed.\\n  event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n\\n  /**\\n   * @dev Sets the ABI associated with an INS node. Nodes may have one ABI of each content type. To remove an ABI, set it\\n   * to the empty string.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   * - The content type must be powers of 2.\\n   *\\n   * Emitted an event {ABIChanged}.\\n   *\\n   * @param node The node to update.\\n   * @param contentType The content type of the ABI\\n   * @param data The ABI data.\\n   */\\n  function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\\n\\n  /**\\n   * @dev Returns the ABI associated with an INS node.\\n   * Defined in EIP-205, see more at https://eips.ethereum.org/EIPS/eip-205\\n   *\\n   * @param node The INS node to query\\n   * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n   * @return contentType The content type of the return value\\n   * @return data The ABI data\\n   */\\n  function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256 contentType, bytes memory data);\\n}\\n\",\"keccak256\":\"0xc701a6cafa883d6607b5916dfb4277099f39c450930d776da36a7acc2b2498c0\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IAddressResolver {\\n  /// @dev Emitted when an address of a node is changed.\\n  event AddrChanged(bytes32 indexed node, address addr);\\n\\n  /**\\n   * @dev Sets the address associated with an INS node.\\n   *\\n   * Requirement:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {AddrChanged}.\\n   *\\n   * @param node The node to update.\\n   * @param addr The address to set.\\n   */\\n  function setAddr(bytes32 node, address addr) external;\\n\\n  /**\\n   * @dev Returns the address associated with an INS node.\\n   * @param node The INS node to query.\\n   * @return The associated address.\\n   */\\n  function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0xb914cb4a730d20c867805fd148e7574c6565bc6c0a129825cdf3cf4f2f7f72d0\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IContentHashResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IContentHashResolver {\\n  /// @dev Emitted when the content hash of a node is changed.\\n  event ContentHashChanged(bytes32 indexed node, bytes hash);\\n\\n  /**\\n   * @dev Sets the content hash associated with an INS node.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {ContentHashChanged}.\\n   *\\n   * @param node The node to update.\\n   * @param hash The content hash to set\\n   */\\n  function setContentHash(bytes32 node, bytes calldata hash) external;\\n\\n  /**\\n   * @dev Returns the content hash associated with an INS node.\\n   * @param node The INS node to query.\\n   * @return The associated content hash.\\n   */\\n  function contentHash(bytes32 node) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0xfbdc7211a813065e5cc2bdd3640c13f01c87b5f31fda86e562b0525628602c00\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IDNSRecordResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSRecordResolver {\\n  /// @dev Emitted whenever a given node/name/resource's RRSET is updated.\\n  event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\\n  /// @dev Emitted whenever a given node/name/resource's RRSET is deleted.\\n  event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\\n\\n  /**\\n   * @dev Set one or more DNS records.  Records are supplied in wire-format.  Records with the same node/name/resource\\n   * must be supplied one after the other to ensure the data is updated correctly. For example, if the data was\\n   * supplied:\\n   *   a.example.com IN A 1.2.3.4\\n   *   a.example.com IN A 5.6.7.8\\n   *   www.example.com IN CNAME a.example.com.\\n   * then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was\\n   * supplied:\\n   *   a.example.com IN A 1.2.3.4\\n   *   www.example.com IN CNAME a.example.com.\\n   *   a.example.com IN A 5.6.7.8\\n   * then this would store the first A record, the CNAME, then the second A record which would overwrite the first.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * @param node the namehash of the node for which to set the records\\n   * @param data the DNS wire format records to set\\n   */\\n  function setDNSRecords(bytes32 node, bytes calldata data) external;\\n\\n  /**\\n   * @dev Obtain a DNS record.\\n   * @param node the namehash of the node for which to fetch the record\\n   * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n   * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n   * @return the DNS record in wire format if present, otherwise empty\\n   */\\n  function dnsRecord(bytes32 node, bytes32 name, uint16 resource) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x2341266d70b60f5bb666c066aaf1fdb35be81277bcdd04e3bf93ee774ae4d2f6\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IDNSZoneResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IDNSZoneResolver {\\n  /// @dev Emitted whenever a given node's zone hash is updated.\\n  event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\\n\\n  /**\\n   * @dev Sets the hash for the zone.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {DNSZonehashChanged}.\\n   *\\n   * @param node The node to update.\\n   * @param hash The zonehash to set\\n   */\\n  function setZonehash(bytes32 node, bytes calldata hash) external;\\n\\n  /**\\n   * @dev Obtains the hash for the zone.\\n   * @param node The INS node to query.\\n   * @return The associated contenthash.\\n   */\\n  function zonehash(bytes32 node) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x42aa5409a184740461e7477b8894d7549fd3908596bb7dba9adab59b8ff4ebed\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IInterfaceResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInterfaceResolver {\\n  /// @dev Emitted when the interface of node is changed.\\n  event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n  /**\\n   * @dev Sets an interface associated with a name.\\n   * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * @param node The node to update.\\n   * @param interfaceID The EIP 165 interface ID.\\n   * @param implementer The address of a contract that implements this interface for this node.\\n   */\\n  function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\\n\\n  /**\\n   * @dev Returns the address of a contract that implements the specified interface for this name.\\n   *\\n   * If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`.\\n   * If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for\\n   * the specified interfaceID, its address will be returned.\\n   *\\n   * @param node The INS node to query.\\n   * @param interfaceID The EIP 165 interface ID to check for.\\n   * @return The address that implements this interface, or 0 if the interface is unsupported.\\n   */\\n  function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\\n}\\n\",\"keccak256\":\"0xb4a1867d5cb899bfdc2e812c4bf9b9d3d14b34e0f72cbeffb4e018f8659b13fc\",\"license\":\"MIT\"},\"src/interfaces/resolvers/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface INameResolver {\\n  /// @dev Emitted when a node name is changed.\\n  event NameChanged(bytes32 indexed node, string name);\\n\\n  /**\\n   * @dev Sets the name associated with an INS node, for reverse records.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {NameChanged}.\\n   *\\n   * @param node The node to update.\\n   */\\n  function setName(bytes32 node, string calldata newName) external;\\n\\n  /**\\n   * @dev Returns the name associated with an INS node, for reverse records.\\n   * @param node The INS node to query.\\n   * @return The associated name.\\n   */\\n  function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xf3dbbe3238d5f1e491a43dbccbd74755fcd325b5c6aef6b7f0819684bd1f9da3\",\"license\":\"UNLICENSED\"},\"src/interfaces/resolvers/IPublicKeyResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPublicKeyResolver {\\n  struct PublicKey {\\n    bytes32 x;\\n    bytes32 y;\\n  }\\n\\n  /// @dev Emitted when a node public key is changed.\\n  event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n  /**\\n   * @dev Sets the SECP256k1 public key associated with an INS node.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {PubkeyChanged}.\\n   *\\n   * @param node The INS node to query\\n   * @param x the X coordinate of the curve point for the public key.\\n   * @param y the Y coordinate of the curve point for the public key.\\n   */\\n  function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\\n\\n  /**\\n   * @dev Returns the SECP256k1 public key associated with an INS node.\\n   * Defined in EIP 619.\\n   *\\n   * @param node The INS node to query\\n   * @return x The X coordinate of the curve point for the public key.\\n   * @return y The Y coordinate of the curve point for the public key.\\n   */\\n  function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n}\\n\",\"keccak256\":\"0x2644fd8d9b951c2aca5521ba519b68d4f3de19b731dae7907b6372e1ceac07ae\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IPublicResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { INSUnified } from \\\"../INSUnified.sol\\\";\\nimport { INSReverseRegistrar } from \\\"../INSReverseRegistrar.sol\\\";\\nimport { IABIResolver } from \\\"./IABIResolver.sol\\\";\\nimport { IAddressResolver } from \\\"./IAddressResolver.sol\\\";\\nimport { IContentHashResolver } from \\\"./IContentHashResolver.sol\\\";\\nimport { IDNSRecordResolver } from \\\"./IDNSRecordResolver.sol\\\";\\nimport { IDNSZoneResolver } from \\\"./IDNSZoneResolver.sol\\\";\\nimport { IInterfaceResolver } from \\\"./IInterfaceResolver.sol\\\";\\nimport { INameResolver } from \\\"./INameResolver.sol\\\";\\nimport { IPublicKeyResolver } from \\\"./IPublicKeyResolver.sol\\\";\\nimport { ITextResolver } from \\\"./ITextResolver.sol\\\";\\nimport { IMulticallable } from \\\"../IMulticallable.sol\\\";\\n\\ninterface IPublicResolver is\\n  IABIResolver,\\n  IAddressResolver,\\n  IContentHashResolver,\\n  IDNSRecordResolver,\\n  IDNSZoneResolver,\\n  IInterfaceResolver,\\n  INameResolver,\\n  IPublicKeyResolver,\\n  ITextResolver,\\n  IMulticallable\\n{\\n  /// @dev See {IERC1155-ApprovalForAll}. Logged when an operator is added or removed.\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /// @dev Logged when a delegate is approved or an approval is revoked.\\n  event Approved(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved);\\n\\n  /**\\n   * @dev Checks if an account is authorized to manage the resolution of a specific RNS node.\\n   * @param node The RNS node.\\n   * @param account The account address being checked for authorization.\\n   * @return A boolean indicating whether the account is authorized.\\n   */\\n  function isAuthorized(bytes32 node, address account) external view returns (bool);\\n\\n  /**\\n   * @dev Retrieves the RNSUnified associated with this resolver.\\n   */\\n  function getRNSUnified() external view returns (INSUnified);\\n\\n  /**\\n   * @dev Retrieves the reverse registrar associated with this resolver.\\n   */\\n  function getReverseRegistrar() external view returns (INSReverseRegistrar);\\n\\n  /**\\n   * @dev This function provides an extra security check when called from privileged contracts (such as\\n   * RONRegistrarController) that can set records on behalf of the node owners.\\n   *\\n   * Reverts if the node is not null but calldata is mismatched.\\n   */\\n  function multicallWithNodeCheck(bytes32 node, bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x97b6f762f25a4dc3f6398a76bbcb7d3922f5f440ee9e0541c83579e09a8f87b7\",\"license\":\"MIT\"},\"src/interfaces/resolvers/ITextResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface ITextResolver {\\n  /// @dev Emitted when a node text is changed.\\n  event TextChanged(bytes32 indexed node, string indexed indexedKey, string key, string value);\\n\\n  /**\\n   * @dev Sets the text data associated with an INS node and key.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {TextChanged}.\\n   *\\n   * @param node The node to update.\\n   * @param key The key to set.\\n   * @param value The text data value to set.\\n   */\\n  function setText(bytes32 node, string calldata key, string calldata value) external;\\n\\n  /**\\n   * Returns the text data associated with an INS node and key.\\n   * @param node The INS node to query.\\n   * @param key The text data key to query.\\n   * @return The associated text data.\\n   */\\n  function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x05ce1760d3a16d99614b1a46c11308238e1ecd8be23f081fac146bbc58961ecf\",\"license\":\"MIT\"},\"src/interfaces/resolvers/IVersionResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVersionResolver {\\n  /// @dev Emitted when the version of a node is changed.\\n  event VersionChanged(bytes32 indexed node, uint64 newVersion);\\n\\n  /**\\n   * @dev Increments the record version associated with an INS node.\\n   *\\n   * Requirements:\\n   * - The method caller must be authorized to change user fields of RNS Token `node`. See indicator\\n   * {ModifyingIndicator.USER_FIELDS_INDICATOR}.\\n   *\\n   * Emits an event {VersionChanged}.\\n   *\\n   * @param node The node to update.\\n   */\\n  function clearRecords(bytes32 node) external;\\n\\n  /**\\n   * @dev Returns the latest version of a node.\\n   */\\n  function recordVersions(bytes32 node) external view returns (uint64);\\n}\\n\",\"keccak256\":\"0xa242d9b3a63c3851d973e11f1c2cd73fb103e462994c55a069c0a386446d13c3\",\"license\":\"MIT\"},\"src/libraries/ErrorHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary ErrorHandler {\\n  error ExternalCallFailed();\\n\\n  function handleRevert(bool status, bytes memory returnOrRevertData) internal pure {\\n    assembly {\\n      if iszero(status) {\\n        let revertLength := mload(returnOrRevertData)\\n        if iszero(iszero(revertLength)) {\\n          // Start of revert data bytes. The 0x20 offset is always the same.\\n          revert(add(returnOrRevertData, 0x20), revertLength)\\n        }\\n\\n        //  revert ExternalCallFailed()\\n        mstore(0x00, 0x350c20f1)\\n        revert(0x1c, 0x04)\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x90049794d1f708cc33034b26d4e8c79c1c4ed630399fccd9280c9d43751e3d0e\",\"license\":\"MIT\"},\"src/resolvers/ABIResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/resolvers/IABIResolver.sol\\\";\\nimport \\\"./BaseVersion.sol\\\";\\n\\nabstract contract ABIResolvable is IABIResolver, ERC165, BaseVersion {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from version => node => content type => abi\\n  mapping(uint64 version => mapping(bytes32 node => mapping(uint256 contentType => bytes abi))) internal _versionalAbi;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override(BaseVersion, ERC165) returns (bool) {\\n    return interfaceID == type(IABIResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IABIResolver\\n   */\\n  function ABI(bytes32 node, uint256 contentTypes) external view virtual override returns (uint256, bytes memory) {\\n    mapping(uint256 contentType => bytes abi) storage abiSet = _versionalAbi[_recordVersion[node]][node];\\n\\n    for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\\n      if ((contentType & contentTypes) != 0 && abiSet[contentType].length > 0) {\\n        return (contentType, abiSet[contentType]);\\n      }\\n    }\\n\\n    return (0, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev See {IABIResolver-setABI}.\\n   */\\n  function _setABI(bytes32 node, uint256 contentType, bytes calldata data) internal {\\n    if (((contentType - 1) & contentType) != 0) revert InvalidContentType();\\n    _versionalAbi[_recordVersion[node]][node][contentType] = data;\\n    emit ABIChanged(node, contentType);\\n  }\\n}\\n\",\"keccak256\":\"0xac8f1a328cf0b63c742bdb22a20131670b7f1ad83aa1d84b449df83d4e72b1b7\",\"license\":\"MIT\"},\"src/resolvers/AddressResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/resolvers/IAddressResolver.sol\\\";\\nimport \\\"./BaseVersion.sol\\\";\\n\\nabstract contract AddressResolvable is IAddressResolver, ERC165, BaseVersion {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from version => node => address\\n  mapping(uint64 version => mapping(bytes32 node => address addr)) internal _versionAddress;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override(BaseVersion, ERC165) returns (bool) {\\n    return interfaceID == type(IAddressResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IAddressResolver\\n   */\\n  function addr(bytes32 node) public view virtual override returns (address payable) {\\n    return payable(_versionAddress[_recordVersion[node]][node]);\\n  }\\n\\n  /**\\n   * @dev See {IAddressResolver-setAddr}.\\n   */\\n  function _setAddr(bytes32 node, address addr_) internal {\\n    emit AddrChanged(node, addr_);\\n    _versionAddress[_recordVersion[node]][node] = addr_;\\n  }\\n}\\n\",\"keccak256\":\"0x9c4b5a43362faad9f03143ab8aeadd9a54d454201bf845bd35639a344e43007d\",\"license\":\"MIT\"},\"src/resolvers/BaseVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/resolvers/IVersionResolver.sol\\\";\\n\\nabstract contract BaseVersion is IVersionResolver, ERC165 {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from node => version\\n  mapping(bytes32 node => uint64 version) internal _recordVersion;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n    return interfaceID == type(IVersionResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IVersionResolver\\n   */\\n  function recordVersions(bytes32 node) external view returns (uint64) {\\n    return _recordVersion[node];\\n  }\\n\\n  /**\\n   * @dev See {IVersionResolver-clearRecords}.\\n   */\\n  function _clearRecords(bytes32 node) internal {\\n    unchecked {\\n      emit VersionChanged(node, ++_recordVersion[node]);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x8d09835f4729b898f9cb443c17436067d809961a57794254e5c7bec5114e719d\",\"license\":\"MIT\"},\"src/resolvers/ContentHashResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/resolvers/IContentHashResolver.sol\\\";\\nimport \\\"./BaseVersion.sol\\\";\\n\\nabstract contract ContentHashResolvable is IContentHashResolver, ERC165, BaseVersion {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from version => node => content hash\\n  mapping(uint64 version => mapping(bytes32 node => bytes contentHash)) internal _versionContentHash;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override(BaseVersion, ERC165) returns (bool) {\\n    return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IContentHashResolver\\n   */\\n  function contentHash(bytes32 node) external view virtual override returns (bytes memory) {\\n    return _versionContentHash[_recordVersion[node]][node];\\n  }\\n\\n  /**\\n   * @dev See {IContentHashResolver-setContentHash}.\\n   */\\n  function _setContentHash(bytes32 node, bytes calldata hash) internal {\\n    _versionContentHash[_recordVersion[node]][node] = hash;\\n    emit ContentHashChanged(node, hash);\\n  }\\n}\\n\",\"keccak256\":\"0xe422bff4488e840435ffc6f865032bf74c61273524389b08933cbbb245146dd0\",\"license\":\"MIT\"},\"src/resolvers/DNSResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/dnssec-oracle/RRUtils.sol\\\";\\nimport \\\"../interfaces/resolvers/IDNSRecordResolver.sol\\\";\\nimport \\\"../interfaces/resolvers/IDNSZoneResolver.sol\\\";\\nimport \\\"./BaseVersion.sol\\\";\\n\\nabstract contract DNSResolvable is IDNSRecordResolver, IDNSZoneResolver, ERC165, BaseVersion {\\n  using RRUtils for *;\\n  using BytesUtils for bytes;\\n\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev The records themselves. Stored as binary RRSETs.\\n  mapping(\\n    uint64 version => mapping(bytes32 node => mapping(bytes32 nameHash => mapping(uint16 resource => bytes data)))\\n  ) private _versionRecord;\\n\\n  /// @dev Count of number of entries for a given name.  Required for DNS resolvers when resolving wildcards.\\n  mapping(uint64 version => mapping(bytes32 node => mapping(bytes32 nameHash => uint16 count))) private\\n    _versionNameEntriesCount;\\n\\n  /**\\n   * @dev Zone hashes for the domains. A zone hash is an EIP-1577 content hash in binary format that should point to a\\n   * resource containing a single zonefile.\\n   */\\n  mapping(uint64 version => mapping(bytes32 node => bytes data)) private _versionZonehash;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override(BaseVersion, ERC165) returns (bool) {\\n    return interfaceID == type(IDNSRecordResolver).interfaceId || interfaceID == type(IDNSZoneResolver).interfaceId\\n      || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @dev Checks whether a given node has records.\\n   * @param node the namehash of the node for which to check the records\\n   * @param name the namehash of the node for which to check the records\\n   */\\n  function hasDNSRecords(bytes32 node, bytes32 name) public view virtual returns (bool) {\\n    return (_versionNameEntriesCount[_recordVersion[node]][node][name] != 0);\\n  }\\n\\n  /**\\n   * @inheritdoc IDNSRecordResolver\\n   */\\n  function dnsRecord(bytes32 node, bytes32 name, uint16 resource) public view virtual override returns (bytes memory) {\\n    return _versionRecord[_recordVersion[node]][node][name][resource];\\n  }\\n\\n  /**\\n   * @inheritdoc IDNSZoneResolver\\n   */\\n  function zonehash(bytes32 node) external view virtual override returns (bytes memory) {\\n    return _versionZonehash[_recordVersion[node]][node];\\n  }\\n\\n  /**\\n   * @dev See {IDNSRecordResolver-setDNSRecords}.\\n   */\\n  function _setDNSRecords(bytes32 node, bytes calldata data) internal {\\n    uint16 resource = 0;\\n    uint256 offset = 0;\\n    bytes memory name;\\n    bytes memory value;\\n    bytes32 nameHash;\\n    uint64 version = _recordVersion[node];\\n    // Iterate over the data to add the resource records\\n    for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\\n      if (resource == 0) {\\n        resource = iter.dnstype;\\n        name = iter.name();\\n        nameHash = keccak256(abi.encodePacked(name));\\n        value = bytes(iter.rdata());\\n      } else {\\n        bytes memory newName = iter.name();\\n        if (resource != iter.dnstype || !name.equals(newName)) {\\n          _setDNSRRSet(node, name, resource, data, offset, iter.offset - offset, value.length == 0, version);\\n          resource = iter.dnstype;\\n          offset = iter.offset;\\n          name = newName;\\n          nameHash = keccak256(name);\\n          value = bytes(iter.rdata());\\n        }\\n      }\\n    }\\n\\n    if (name.length > 0) {\\n      _setDNSRRSet(node, name, resource, data, offset, data.length - offset, value.length == 0, version);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IDNSZoneResolver-setZonehash}.\\n   */\\n  function _setZonehash(bytes32 node, bytes calldata hash) internal {\\n    uint64 currentRecordVersion = _recordVersion[node];\\n    bytes memory oldhash = _versionZonehash[currentRecordVersion][node];\\n    _versionZonehash[currentRecordVersion][node] = hash;\\n    emit DNSZonehashChanged(node, oldhash, hash);\\n  }\\n\\n  /**\\n   * @dev Helper method to set DNS config.\\n   *\\n   * May emit an event {DNSRecordDeleted}.\\n   * May emit an event {DNSRecordChanged}.\\n   *\\n   */\\n  function _setDNSRRSet(\\n    bytes32 node,\\n    bytes memory name,\\n    uint16 resource,\\n    bytes memory data,\\n    uint256 offset,\\n    uint256 size,\\n    bool deleteRecord,\\n    uint64 version\\n  ) private {\\n    bytes32 nameHash = keccak256(name);\\n    bytes memory rrData = data.substring(offset, size);\\n    if (deleteRecord) {\\n      if (_versionRecord[version][node][nameHash][resource].length != 0) {\\n        _versionNameEntriesCount[version][node][nameHash]--;\\n      }\\n      delete (_versionRecord[version][node][nameHash][resource]);\\n      emit DNSRecordDeleted(node, name, resource);\\n    } else {\\n      if (_versionRecord[version][node][nameHash][resource].length == 0) {\\n        _versionNameEntriesCount[version][node][nameHash]++;\\n      }\\n      _versionRecord[version][node][nameHash][resource] = rrData;\\n      emit DNSRecordChanged(node, name, resource, rrData);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcd9cd7b32ee0a019bc6442226c89272ef271f5f9d4adbc4307131c0df94ea6a3\",\"license\":\"MIT\"},\"src/resolvers/InterfaceResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport { BaseVersion } from \\\"./BaseVersion.sol\\\";\\nimport { IInterfaceResolver } from \\\"../interfaces/resolvers/IInterfaceResolver.sol\\\";\\n\\nabstract contract InterfaceResolvable is IInterfaceResolver, ERC165, BaseVersion {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from version => node => interfaceID => address\\n  mapping(uint64 version => mapping(bytes32 node => mapping(bytes4 interfaceID => address addr))) internal\\n    _versionInterface;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override(BaseVersion, ERC165) returns (bool) {\\n    return interfaceID == type(IInterfaceResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc IInterfaceResolver\\n   */\\n  function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view virtual override returns (address) {\\n    address implementer = _versionInterface[_recordVersion[node]][node][interfaceID];\\n    if (implementer != address(0)) return implementer;\\n\\n    address addrOfNode = addr(node);\\n    if (addrOfNode == address(0)) return address(0);\\n\\n    bool success;\\n    bytes memory returnData;\\n\\n    (success, returnData) =\\n      addrOfNode.staticcall(abi.encodeCall(IERC165.supportsInterface, (type(IERC165).interfaceId)));\\n\\n    // EIP 165 not supported by target\\n    if (!_isValidReturnData(success, returnData)) return address(0);\\n\\n    (success, returnData) = addrOfNode.staticcall(abi.encodeCall(IERC165.supportsInterface, (interfaceID)));\\n    // Specified interface not supported by target\\n    if (!_isValidReturnData(success, returnData)) return address(0);\\n\\n    return addrOfNode;\\n  }\\n\\n  /**\\n   * @dev See {IAddressResolver-addr}.\\n   */\\n  function addr(bytes32 node) public view virtual returns (address payable);\\n\\n  /**\\n   * @dev Checks whether the return data is valid.\\n   */\\n  function _isValidReturnData(bool success, bytes memory returnData) internal pure returns (bool) {\\n    return success || returnData.length < 32 || returnData[31] == 0;\\n  }\\n\\n  /**\\n   * @dev See {InterfaceResolver-setInterface}.\\n   */\\n  function _setInterface(bytes32 node, bytes4 interfaceID, address implementer) internal virtual {\\n    _versionInterface[_recordVersion[node]][node][interfaceID] = implementer;\\n    emit InterfaceChanged(node, interfaceID, implementer);\\n  }\\n}\\n\",\"keccak256\":\"0x16136902c24340f0feecdfcfd7b3549f310d30a0c78b4f7744eb209bd06f85ae\",\"license\":\"MIT\"},\"src/resolvers/NameResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { BaseVersion } from \\\"./BaseVersion.sol\\\";\\nimport { INameResolver } from \\\"../interfaces/resolvers/INameResolver.sol\\\";\\n\\nabstract contract NameResolvable is INameResolver, BaseVersion {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev mapping from version => node => name\\n  mapping(uint64 version => mapping(bytes32 node => string name)) internal _versionName;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n    return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc INameResolver\\n   */\\n  function name(bytes32 node) public view virtual override returns (string memory) {\\n    return _versionName[_recordVersion[node]][node];\\n  }\\n\\n  /**\\n   * @dev See {INameResolver-setName}.\\n   */\\n  function _setName(bytes32 node, string memory newName) internal virtual {\\n    _versionName[_recordVersion[node]][node] = newName;\\n    emit NameChanged(node, newName);\\n  }\\n}\\n\",\"keccak256\":\"0x4a2ca2f53f96792df863c5d87ff9399470212b5d570d2f4728191dbda3fa10c1\",\"license\":\"MIT\"},\"src/resolvers/PublicKeyResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { BaseVersion } from \\\"./BaseVersion.sol\\\";\\nimport { IPublicKeyResolver } from \\\"../interfaces/resolvers/IPublicKeyResolver.sol\\\";\\n\\nabstract contract PublicKeyResolvable is BaseVersion, IPublicKeyResolver {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev Mapping from version => node => public key\\n  mapping(uint64 version => mapping(bytes32 node => PublicKey publicKey)) internal _versionPublicKey;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n    return interfaceID == type(IPublicKeyResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @dev See {IPublicKeyResolver-pubkey}.\\n   */\\n  function pubkey(bytes32 node) external view virtual override returns (bytes32 x, bytes32 y) {\\n    uint64 currentRecordVersion = _recordVersion[node];\\n    return (_versionPublicKey[currentRecordVersion][node].x, _versionPublicKey[currentRecordVersion][node].y);\\n  }\\n\\n  /**\\n   * @dev See {IPublicKeyResolver-setPubkey}.\\n   */\\n  function _setPubkey(bytes32 node, bytes32 x, bytes32 y) internal virtual {\\n    _versionPublicKey[_recordVersion[node]][node] = PublicKey(x, y);\\n    emit PubkeyChanged(node, x, y);\\n  }\\n}\\n\",\"keccak256\":\"0x8d6c1d0d7f4e795cc21f07179d4d355b064f785f5bdcd0e57d603e6c8e8803dd\",\"license\":\"MIT\"},\"src/resolvers/PublicResolver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { IVersionResolver } from \\\"../interfaces/resolvers/IVersionResolver.sol\\\";\\nimport { Multicallable } from \\\"../extensions/Multicallable.sol\\\";\\nimport { USER_FIELDS_INDICATOR } from \\\"../types/ModifyingIndicator.sol\\\";\\nimport { ABIResolvable } from \\\"./ABIResolvable.sol\\\";\\nimport { AddressResolvable } from \\\"./AddressResolvable.sol\\\";\\nimport { ContentHashResolvable } from \\\"./ContentHashResolvable.sol\\\";\\nimport { DNSResolvable } from \\\"./DNSResolvable.sol\\\";\\nimport { InterfaceResolvable } from \\\"./InterfaceResolvable.sol\\\";\\nimport { NameResolvable } from \\\"./NameResolvable.sol\\\";\\nimport { PublicKeyResolvable } from \\\"./PublicKeyResolvable.sol\\\";\\nimport { TextResolvable } from \\\"./TextResolvable.sol\\\";\\nimport \\\"../interfaces/resolvers/IPublicResolver.sol\\\";\\n\\n/**\\n * @title Public Resolver\\n * @notice Customized version of PublicResolver: https://github.com/ensdomains/ens-contracts/blob/0c75ba23fae76165d51c9c80d76d22261e06179d/contracts/resolvers/PublicResolver.sol\\n * @dev A simple resolver anyone can use, only allows the owner of a node to set its address.\\n */\\ncontract PublicResolver is\\n  IPublicResolver,\\n  ABIResolvable,\\n  AddressResolvable,\\n  ContentHashResolvable,\\n  DNSResolvable,\\n  InterfaceResolvable,\\n  NameResolvable,\\n  PublicKeyResolvable,\\n  TextResolvable,\\n  Multicallable,\\n  Initializable\\n{\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n\\n  /// @dev The RNS Unified contract\\n  INSUnified internal _rnsUnified;\\n\\n  /// @dev The reverse registrar contract\\n  INSReverseRegistrar internal _reverseRegistrar;\\n\\n  modifier onlyAuthorized(bytes32 node) {\\n    _requireAuthorized(node, msg.sender);\\n    _;\\n  }\\n\\n  constructor() payable {\\n    _disableInitializers();\\n  }\\n\\n  function initialize(INSUnified rnsUnified, INSReverseRegistrar reverseRegistrar) external initializer {\\n    _rnsUnified = rnsUnified;\\n    _reverseRegistrar = reverseRegistrar;\\n  }\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID)\\n    public\\n    view\\n    override(\\n      ABIResolvable,\\n      AddressResolvable,\\n      ContentHashResolvable,\\n      DNSResolvable,\\n      InterfaceResolvable,\\n      NameResolvable,\\n      PublicKeyResolvable,\\n      TextResolvable,\\n      Multicallable\\n    )\\n    returns (bool)\\n  {\\n    return super.supportsInterface(interfaceID);\\n  }\\n\\n  /// @inheritdoc IPublicResolver\\n  function getRNSUnified() external view returns (INSUnified) {\\n    return _rnsUnified;\\n  }\\n\\n  /// @inheritdoc IPublicResolver\\n  function getReverseRegistrar() external view returns (INSReverseRegistrar) {\\n    return _reverseRegistrar;\\n  }\\n\\n  /// @inheritdoc IPublicResolver\\n  function multicallWithNodeCheck(bytes32 node, bytes[] calldata data)\\n    external\\n    override\\n    returns (bytes[] memory results)\\n  {\\n    if (node != 0) {\\n      for (uint256 i; i < data.length;) {\\n        require(node == bytes32(data[i][4:36]), \\\"PublicResolver: All records must have a matching namehash\\\");\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    }\\n\\n    return _tryMulticall(true, data);\\n  }\\n\\n  /// @inheritdoc IVersionResolver\\n  function clearRecords(bytes32 node) external onlyAuthorized(node) {\\n    _clearRecords(node);\\n  }\\n\\n  /// @inheritdoc IABIResolver\\n  function setABI(bytes32 node, uint256 contentType, bytes calldata data) external onlyAuthorized(node) {\\n    _setABI(node, contentType, data);\\n  }\\n\\n  /// @inheritdoc IAddressResolver\\n  function setAddr(bytes32 node, address addr_) external onlyAuthorized(node) {\\n    revert(\\\"PublicResolver: Cannot set address\\\");\\n    _setAddr(node, addr_);\\n  }\\n\\n  /// @inheritdoc IContentHashResolver\\n  function setContentHash(bytes32 node, bytes calldata hash) external onlyAuthorized(node) {\\n    _setContentHash(node, hash);\\n  }\\n\\n  /// @inheritdoc IDNSRecordResolver\\n  function setDNSRecords(bytes32 node, bytes calldata data) external onlyAuthorized(node) {\\n    _setDNSRecords(node, data);\\n  }\\n\\n  /// @inheritdoc IDNSZoneResolver\\n  function setZonehash(bytes32 node, bytes calldata hash) external onlyAuthorized(node) {\\n    _setZonehash(node, hash);\\n  }\\n\\n  /// @inheritdoc IInterfaceResolver\\n  function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external onlyAuthorized(node) {\\n    _setInterface(node, interfaceID, implementer);\\n  }\\n\\n  /// @inheritdoc INameResolver\\n  function setName(bytes32 node, string calldata newName) external onlyAuthorized(node) {\\n    _setName(node, newName);\\n  }\\n\\n  /// @inheritdoc IPublicKeyResolver\\n  function setPubkey(bytes32 node, bytes32 x, bytes32 y) external onlyAuthorized(node) {\\n    _setPubkey(node, x, y);\\n  }\\n\\n  /// @inheritdoc ITextResolver\\n  function setText(bytes32 node, string calldata key, string calldata value) external onlyAuthorized(node) {\\n    _setText(node, key, value);\\n  }\\n\\n  /// @inheritdoc IPublicResolver\\n  function isAuthorized(bytes32 node, address account) public view returns (bool authorized) {\\n    (authorized,) = _rnsUnified.canSetRecord(account, uint256(node), USER_FIELDS_INDICATOR);\\n  }\\n\\n  /// @dev Override {IAddressResolvable-addr}.\\n  function addr(bytes32 node)\\n    public\\n    view\\n    virtual\\n    override(AddressResolvable, IAddressResolver, InterfaceResolvable)\\n    returns (address payable)\\n  {\\n    return payable(_rnsUnified.ownerOf(uint256(node)));\\n  }\\n\\n  /// @dev Override {INameResolver-name}.\\n  function name(bytes32 node) public view virtual override(INameResolver, NameResolvable) returns (string memory) {\\n    address reversedAddress = _reverseRegistrar.getAddress(uint256(node));\\n    string memory domainName = super.name(node);\\n    uint256 tokenId = uint256(_rnsUnified.namehash(domainName));\\n    return _rnsUnified.ownerOf(tokenId) == reversedAddress ? domainName : \\\"\\\";\\n  }\\n\\n  /**\\n   * @dev Reverts if the msg sender is not authorized.\\n   */\\n  function _requireAuthorized(bytes32 node, address account) internal view {\\n    require(isAuthorized(node, account), \\\"PublicResolver: unauthorized caller\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xd801a8373c330e97c7e3acf5cab650bcfc66f792ed9791c509fbf09adb2cc200\",\"license\":\"MIT\"},\"src/resolvers/TextResolvable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { BaseVersion } from \\\"./BaseVersion.sol\\\";\\nimport { ITextResolver } from \\\"../interfaces/resolvers/ITextResolver.sol\\\";\\n\\nabstract contract TextResolvable is BaseVersion, ITextResolver {\\n  /// @dev Gap for upgradeability.\\n  uint256[50] private ____gap;\\n  /// @dev Mapping from version => node => key => text\\n  mapping(uint64 version => mapping(bytes32 node => mapping(string key => string text))) internal _versionText;\\n\\n  /**\\n   * @dev Override {IERC165-supportsInterface}.\\n   */\\n  function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n    return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);\\n  }\\n\\n  /**\\n   * @inheritdoc ITextResolver\\n   */\\n  function text(bytes32 node, string calldata key) external view virtual override returns (string memory) {\\n    return _versionText[_recordVersion[node]][node][key];\\n  }\\n\\n  /**\\n   * @dev See {ITextResolver-setText}.\\n   */\\n  function _setText(bytes32 node, string calldata key, string calldata value) internal virtual {\\n    _versionText[_recordVersion[node]][node][key] = value;\\n    emit TextChanged(node, key, key, value);\\n  }\\n}\\n\",\"keccak256\":\"0x96ba97e9d286137e00aef1c40934fa5175be44b11048ac3fea1c8e59d872df2e\",\"license\":\"MIT\"},\"src/types/ModifyingIndicator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ntype ModifyingIndicator is uint256;\\n\\nusing { hasAny } for ModifyingIndicator global;\\nusing { or as | } for ModifyingIndicator global;\\nusing { and as & } for ModifyingIndicator global;\\nusing { eq as == } for ModifyingIndicator global;\\nusing { not as ~ } for ModifyingIndicator global;\\nusing { neq as != } for ModifyingIndicator global;\\n\\n/// @dev Indicator for modifying immutable fields: Depth, ParentId, Label. See struct {INSUnified.ImmutableRecord}.\\nModifyingIndicator constant IMMUTABLE_FIELDS_INDICATOR = ModifyingIndicator.wrap(0x7);\\n\\n/// @dev Indicator for modifying user fields: Resolver, Owner. See struct {INSUnified.MutableRecord}.\\nModifyingIndicator constant USER_FIELDS_INDICATOR = ModifyingIndicator.wrap(0x18);\\n\\n/// @dev Indicator when modifying all of the fields in {ModifyingField}.\\nModifyingIndicator constant ALL_FIELDS_INDICATOR = ModifyingIndicator.wrap(type(uint256).max);\\n\\nfunction eq(ModifyingIndicator self, ModifyingIndicator other) pure returns (bool) {\\n  return ModifyingIndicator.unwrap(self) == ModifyingIndicator.unwrap(other);\\n}\\n\\nfunction neq(ModifyingIndicator self, ModifyingIndicator other) pure returns (bool) {\\n  return !eq(self, other);\\n}\\n\\nfunction not(ModifyingIndicator self) pure returns (ModifyingIndicator) {\\n  return ModifyingIndicator.wrap(~ModifyingIndicator.unwrap(self));\\n}\\n\\nfunction or(ModifyingIndicator self, ModifyingIndicator other) pure returns (ModifyingIndicator) {\\n  return ModifyingIndicator.wrap(ModifyingIndicator.unwrap(self) | ModifyingIndicator.unwrap(other));\\n}\\n\\nfunction and(ModifyingIndicator self, ModifyingIndicator other) pure returns (ModifyingIndicator) {\\n  return ModifyingIndicator.wrap(ModifyingIndicator.unwrap(self) & ModifyingIndicator.unwrap(other));\\n}\\n\\nfunction hasAny(ModifyingIndicator self, ModifyingIndicator other) pure returns (bool) {\\n  return self & other != ModifyingIndicator.wrap(0);\\n}\\n\",\"keccak256\":\"0xe364b4d2e480a7f3e392a40f792303c0febf79c1a623eb4c2278f652210e2e6c\",\"license\":\"MIT\"}},\"version\":1}",
  "nonce": 182505,
  "numDeployments": 1,
  "storageLayout": {
    "storage": [
      {
        "astId": 67858,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 67863,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_recordVersion",
        "offset": 0,
        "slot": "50",
        "type": "t_mapping(t_bytes32,t_uint64)"
      },
      {
        "astId": 67613,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 67622,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionalAbi",
        "offset": 0,
        "slot": "101",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage)))"
      },
      {
        "astId": 67768,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 67775,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionAddress",
        "offset": 0,
        "slot": "152",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_address))"
      },
      {
        "astId": 67931,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "153",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 67938,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionContentHash",
        "offset": 0,
        "slot": "203",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))"
      },
      {
        "astId": 68030,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "204",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 68041,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionRecord",
        "offset": 0,
        "slot": "254",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))"
      },
      {
        "astId": 68050,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionNameEntriesCount",
        "offset": 0,
        "slot": "255",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16)))"
      },
      {
        "astId": 68057,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionZonehash",
        "offset": 0,
        "slot": "256",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))"
      },
      {
        "astId": 68508,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "257",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 68517,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionInterface",
        "offset": 0,
        "slot": "307",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes4,t_address)))"
      },
      {
        "astId": 68732,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "308",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 68739,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionName",
        "offset": 0,
        "slot": "358",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_string_storage))"
      },
      {
        "astId": 68819,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "359",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 68827,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionPublicKey",
        "offset": 0,
        "slot": "409",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_struct(PublicKey)65836_storage))"
      },
      {
        "astId": 69423,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "410",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 69432,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_versionText",
        "offset": 0,
        "slot": "460",
        "type": "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage)))"
      },
      {
        "astId": 50000,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_initialized",
        "offset": 0,
        "slot": "461",
        "type": "t_uint8"
      },
      {
        "astId": 50003,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_initializing",
        "offset": 1,
        "slot": "461",
        "type": "t_bool"
      },
      {
        "astId": 68967,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "____gap",
        "offset": 0,
        "slot": "462",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 68971,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_rnsUnified",
        "offset": 0,
        "slot": "512",
        "type": "t_contract(INSUnified)65128"
      },
      {
        "astId": 68975,
        "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
        "label": "_reverseRegistrar",
        "offset": 0,
        "slot": "513",
        "type": "t_contract(INSReverseRegistrar)64874"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)50_storage": {
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600",
        "base": "t_uint256"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_bytes_storage": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_contract(INSReverseRegistrar)64874": {
        "encoding": "inplace",
        "label": "contract INSReverseRegistrar",
        "numberOfBytes": "20"
      },
      "t_contract(INSUnified)65128": {
        "encoding": "inplace",
        "label": "contract INSUnified",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes32,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))"
      },
      "t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(bytes32 => uint16))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint16)"
      },
      "t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(bytes4 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_address)"
      },
      "t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(string => string))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_string_memory_ptr,t_string_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint16 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint16,t_bytes_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint256 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bytes_storage)"
      },
      "t_mapping(t_bytes32,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_bytes32,t_struct(PublicKey)65836_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct IPublicKeyResolver.PublicKey)",
        "numberOfBytes": "32",
        "value": "t_struct(PublicKey)65836_storage"
      },
      "t_mapping(t_bytes32,t_uint16)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint16)",
        "numberOfBytes": "32",
        "value": "t_uint16"
      },
      "t_mapping(t_bytes32,t_uint64)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_mapping(t_bytes4,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_string_memory_ptr,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_uint16,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_uint16",
        "label": "mapping(uint16 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_uint256,t_bytes_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes)",
        "numberOfBytes": "32",
        "value": "t_bytes_storage"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_address))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_address)"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => bytes))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_bytes_storage)"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16)))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16))"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes4,t_address)))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage)))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => mapping(string => string)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage)))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_string_storage))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => string))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_string_storage)"
      },
      "t_mapping(t_uint64,t_mapping(t_bytes32,t_struct(PublicKey)65836_storage))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(bytes32 => struct IPublicKeyResolver.PublicKey))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_struct(PublicKey)65836_storage)"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(PublicKey)65836_storage": {
        "encoding": "inplace",
        "label": "struct IPublicKeyResolver.PublicKey",
        "numberOfBytes": "64",
        "members": [
          {
            "astId": 65833,
            "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
            "label": "x",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 65835,
            "contract": "src/resolvers/PublicResolver.sol:PublicResolver",
            "label": "y",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ]
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "timestamp": 1697372891,
  "userdoc": {
    "version": 1,
    "kind": "user",
    "methods": {
      "text(bytes32,string)": {
        "notice": "Returns the text data associated with an INS node and key."
      }
    },
    "errors": {
      "InvalidContentType()": [
        {
          "notice": "Thrown when the input content type is invalid."
        }
      ]
    },
    "notice": "Customized version of PublicResolver: https://github.com/ensdomains/ens-contracts/blob/0c75ba23fae76165d51c9c80d76d22261e06179d/contracts/resolvers/PublicResolver.sol"
  }
}